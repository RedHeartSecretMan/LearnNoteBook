# ***我的数据结构与算法***

[toc]



## **绪论**

**数据结构的三要素是逻辑结构、物理结构和数据运算；算法的性能分析时间复杂度和空间复杂度**



### **数据结构**

**「数据」是信息的载体，是描述客观事物属性的数、字符和所有能输入到计算机中被识别和处理的符号的集合**

**「数据元素」是数据的基本单位。「数据项」是数据元素不可分割的最小单位，比如一个学生记录是数据元素相应的数据项就是学号、姓名、性别和年龄；「数据对象」是性质相同的数据元素构成的集合，是数据的子集**

**「数据类型」是一组性质相同的值（可认为是数据元素）的集合与定义在此集合上的一组操作的总称，值有哪些特性？首先是用二进制保存，其次是有长度限，然后是编码的语义信息，根据这些特征来进行分类，基础数据类型包括字节、字、双字、布尔值、数值和字符等，可以划分为「原子类型」即值不可再分的数据类型、「结构类型」即值可以再分解为若干分量的数据类型和「抽象数据类型」（与在计算机内部如何表示和实现无关）用数据对象、数据关系和基本操作集的三元组定义**

**「数据结构」是一个数据元素与数据元素间关系的集合，数据元素通常都不是孤立存在的，在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构。数据结构的三要素是「逻辑结构、存储结构和数据的运算」。数据的逻辑结构和存储结构是密不可分的两个方面，算法的设计取决于所选定的逻辑结构，算法的实现依赖于所采用的存储结构**

**数据类型与数据结构是描述数据的不同角度，不完全平行的不断发展的概念。数据类型描述人的视角下数据的形状（大小与多少）、数据的物理类型（整数、浮点数、字符串、列表和字典等）和数据的变化（加减乘除与增查删改等）；数据结构描述人的视角下数据的形状、数据的组织关系（逻辑上抽象的关系与计算机中物理关系）和数据的变化（增查删改等），本身并没有很强的必然关系，不过抽象数据类型的恰好可以完整定义数据结构，因为，一个数据结构的定义取决于所选定的逻辑结构，而一个数据结构的实现依赖于所采用的存储结构，抽象数据类型不关心存储结构，只描述数据的逻辑结构和抽象运算，所以，它不能实现一个数据结构，但可以定义一个数据结构**

**数据的逻辑结构是面向实际问题的角度出发的，只采用抽象表达方式，独立于存储结构；而数据的存储结构是逻辑结构在计算机上的映射，它不能独立于逻辑结构而存在**

**顺序表、哈希表和单链表是三种不同的数据结构，既描述逻辑结构，又描述存储结构和数据运算，有序表是指关键字有序的线性表，仅描述元素之间的逻辑关系，它既可以链式存储，又可以顺序存储，循环队列是用顺序表表示的队列，是一种数据结构。栈是一种抽象数据类型，只表示逻辑结构，可采用顺序存储或链式存储**



#### **逻辑结构**

**数据的逻辑结构是指数据元素之间的逻辑关系，可分为线性结构和非线性结构，抽象于计算机之外。数据元素之间的关系就像一串糖葫芦，从头部的糖葫芦开始串联到尾部的糖葫芦结束，中间的糖葫芦有相互间的前后关系即前驱与后继**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220328145709575.png" alt="image-20220328145709575" width="800px;" />



##### **线性结构**

- **数据元素之间存在一对一的有序的关系，存在唯一的一个第一个数据元素，存在唯一的一个最后的数据元素，除最后数据元素之外，其它数据元素均有唯一的后继，除第一数据元素之外，其它数据元素均有唯一的前驱**

  > **常见的线性结构有一般线性表、受限线性表（栈、队列和串）、线性表推广（数组）等**



##### **非线性结构**

###### **集合结构**

- **数据元素之间除了同属于一个集合再无其他关系**

###### **树形结构**

- **数据元素之间存在一对多的关系**

  > **常见的树形结构有一般树与二叉树等** 



###### **图状结构**

- **数据元素之间存在多对多的关系**

  > **常见的图状结构有有向图与无向图等**  



#### **存储结构**

**数据的存储结构也称物理结构是逻辑结构在计算机中的表示，包括数据元素的表示与关系的表示，基于物理存储器件的支撑通过计算机语言的软件实现。当我们设计好数据的逻辑结构后，需要将数据以某种方式存到内存中，此时我们可以选择顺序存储到存储单元连续的内存中，也可以选择其他方式存储到存储单元不连续的内存中，存储结构主要有顺序存储、链式存储、索引存储和散列存储等**



##### **顺序存储**

**逻辑上相邻的数据元素存储在物理位置相邻的存储单元中，元素间的逻辑关系自然的由存储单元的相邻关系体现，因此不需要额外的指针记录数据元素与前驱后继的内存地址**

- **优点是可以实现随机存取（获取元素时只需要根据参考元素计算偏移量即可直接存取），缺点是只能使用相邻的整块存储单元，容易产生内存碎片**



##### **链式存储**

**逻辑上相邻的数据元素存储的存储单元的物理位置未必相邻，通过指针记录前驱与后继的内存地址来表示相邻数据元素的逻辑关系**

- **优点是避免了内存碎片，充分利用了存储单元，缺点是每个元素都需要存储额外的指针占用了存储空间，且只能顺序存取（存取数据元素时需要从存储的第一个数据元素的结点中的指针开始找到存储的逻辑上相邻的数据元素的结点且不断重复）**



##### **索引存储**

**索引存储分别存放数据元素与数据元素间的关系，存储元素时额外建立索引表（由若干索引项组成）一般形式是关键字或地址，若每个数据元素在索引表中都有一个索引项，则该索引表称「稠密索引」，若一组数据元素在索引表中只对应于一个索引项，则该索引表称「稀疏索引」**

- **优点是检索速度快，缺点是建立的索引表占据了额外的时间与存储空间，增加与删除数据时需要同时修改索引表增加了额外的时间**



##### **散列存储**

**根据元素的关键字直接计算出元素的存储地址，也称哈希存储**

- **优点是检索、增加和删除都很快，缺点是散列函数不好可能出现元素存储单元的冲突，解决冲突需要增加额外的时间和空间开销**



#### **数据运算**

**数据运算包括了运算的定义与运算的实现。运算的定义针对逻辑结构指出运算的功能；运算的实现针对存储结构指出运算的操作**





### **算法**

**算法是针对特定问题求解步骤的一种描述，是指令的有限序列，每条指令表示一个或多个操作，具有五个特征，有穷性，有限步之后结束；确定性，不存在二义性没有歧义；可行性，比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成；输入，有零或多个能被计算机处理的各种类型数据，如数字，音频，图像等输入；输出，有一至多个与输入有某种特定关系的输出**

**通常设计一个好的算法需要考虑，正确性，算法能够正确的解决求解的问题；可读性，算法应该能够让人们良好的理解；健壮性，输入非法数据时，算法可以适当的做出正确反应或进行处理而不会产生莫名其妙的输出结果；高性能，时间复杂度和空间复杂度低，数据结构，好的数据结构为算法提供有力支撑**



#### **时间复杂度**

**一个语句的频度指该语句在算法中被重复执行的次数，算法中全部语句的频度之和记为 $T(n)$ 是算法问题规模 $n$（参数量）的函数，时间复杂度主要分析 $T(n)$ 的数量级。算法中基本运算的即最深层循环内的语句的频度与 $T(n)$ 同数量级，因此只需分析最基本的运算的频度 $f(n)$ 即可，记为 $T(n)=O(f(n))$，其中 $O$ 计算 $f(n)$ 的数量级等价 $T(n)$ 的数量级，算法的时间复杂度还取决于输入数据的性质，比如正向遍历查找一个长度为 $n$ 的数组 $A[0,\cdots,n-1]$ 中的元素 $b$**

```c
#include <stdio.h>

/* 函数声明 */
int iadd (int b);

/* 定义全局变量 */
int i = 0;
int n = 10;
int A[10] = {0,1,2,3,4,5,6,7,8,9};

int main ()
{
  /* 定义局部变量 */
  int b1 = 0;
  int b2 = 9;

  iadd(b1);
  iadd(b2);

  return 0;
}

int iadd (int b)
{
  /* while 循环执行 */
  while(i<=n-1&&(A[i]!=b))
  {
    i++;
  }
  
  /* printf 输出 */
  printf("%d\n", i);
  return i;
}
```



**若恰好在第一个位置时基本运算 $\mathcal{i++}$ 的频度 $f(n)=0$，时间复杂度为常数阶 $O(1)$，或恰好在最后一个位置时基本运算 $\mathcal{i++}$ 的频度 $f(n)=n$，时间复杂度为线性阶 $O(n)$，最坏时间复杂度是考虑输入使得 $f(n)$ 最大，平均时间复杂度是指所有可能输入的 $f(n)$ 的期望，最好时间复杂度是考虑输入使得 $f(n)$ 最小，通常时间复杂度指最坏时间复杂度**

**分析程序的时间复杂度时有两条规则**

- **加法规则**

  > **$T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))$**

- **乘法规则**

  > **$T(n)=T_1(n)\cdot T_2(n)=O(f(n))\cdot O(g(n))=O(max(f(n)\cdot g(n)))$**

**循环主体中的变量与循环条件相关，将变量代入循环条件求出循环次数；循环主体中的变量与循环条件不相关，递归程序采用数学归纳法推导循环次数，非递归程序直接累计循环次数**

**常见的渐进时间复杂度**

- $O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$



#### **空间复杂度**

**一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据，还需要存储空间来存放数据进行的操作与输出数据，算法的空间复杂度 $S(n)$ 定义为该算法所耗费的存储空间，它是问题规模 $n$（参数量）的函数记为 $S(n)=O(g(n))$**







## **一般线性表**

**一般线性表简称线性表，是线性逻辑结构且具有相同数据类型的 $n$ 个数据元素的有限序列。其中 $n$ 为表长。当 $n=0$ 时 线性表是一个空表；线性表中第一个数据元素称为表头数据元素有且只有一个直接后继，最后一个数据元素称为表尾数据元素有且只有一个直接前驱，其他数据元素有且仅有一个直接前驱与直接后继，存储结构分为顺序存储与链式存储分别对应一般线性表中的顺序表于链表，一般线性表的主要操作有**

- **`Init()` 初始化表操作，构造一个空的线性表**
- **`Length(L)` 求表长操作，返回线性表工的长度，即表 $L$ 中数据元素的个数**
- **`Print(L)` 输出操作，按前后顺序输出线性表工 的所有元素值**
- **`Insert(L,i,e)` 插入操作，在表 $L$ 中的第i个位置上插入指定元素 $e$**
- **`Delete(L,i)` 删除操作，删除表 $L$ 中第 $i$ 个位置的元素**
- **`LocateElement(L,e)` 按值查找操作，在表 $L$ 中查找具有给定元素的值的位序**
- **`GetElement(L,i)` 按位查找操作，获取表 $L$ 中第 $i$ 个位置的元素的值**
- **`Empty(L)` 判空操作，若 $L$ 为空表，则返回 $true$，否则返回 $false$**
- **`Destroy(L)` 销毁操作，销毁线性表，并释放线性表 $L$ 所占用的内存空间**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220328161128357.png" alt="image-20220328161128357" width="300px;" />



**在 $C$ 语言中，存在一个称之为栈的自动存储区，$int\;array[10]$ 内存空间由编译器自动分配释放；存在一个称之为的堆的自由存储区，用 $malloc()$ 与 $free()$ 函数手动完成动态内存管理而非系统自动，利用 $malloc()$ 为定义的数据结构分配一块实际所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为基地址；若分配失败，则返回 $NULL$，已分配的空间可用 $free()$ 释放**



### **顺序表**

**顺序存储的线性表称为顺序表，它用一组地址连续的存储空间依次存储数据元素，从而使得逻辑上相邻的两个数据元素在物理位置上也相邻，顺序表至少包含三个属性**

- **存储空间的起始位置**

- **顺序表最大存储空间**

  > **定义好允许的最大长度，也可以动态分配存储空间，在程序执行过程中通过动态存储分配语句分配**

- **顺序表当前的长度**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220328195657245.png" alt="image-20220328195657245" width="500px;" />



**顺序表最主要的特点是随机访问，通过首地址和数据元素序号可以在 $O(1)$ 的时间内找到指定的数据元素，其次顺序表的存储密度高，每个结点只存储数据元素。顺序表逻辑上相邻的元素物理上也相邻，无需消耗额外存储空间建立顺序表中数据元素间的逻辑关系，但是插入、删除和查找等操作需要移动大量元素**



#### **顺序表的实例**

```c
#include <stdio.h>
#include <stdlib.h>
#define Size 5

// 定义布尔类型false=0与true=1
typedef enum
{
    false,
    true
} bool;

// 定义结构类型SequenceTabel[...]叫ST
typedef struct SequenceTabel
{
    int *head;
    int size;
    int length;
} ST;

/* Init */
ST initST();
/* Length */
int lengthST(ST st);
/* Print */
void printST(ST st);
/* Insert */
ST insertST(ST st, int idx, int elem);
/* Delete */
ST deleteST(ST st, int idx);
/* LocateElement */
bool LocateelementST(ST st, int elem);
/* GetElement */
int getelementST(ST st, int idx);
/* Empty */
bool emptyST(ST st);
/* Destroy */
bool destroyST(ST st);

ST initST()
{
    ST st;
    /* malloc申请一块连续的指定大小的内存块区域作为数组
    分配成功则返回数组的头指针，否则返回空指针NULL
    calloc(size,sizeof(int))会初始化数组元素为0
    以头指针动态分配内存空间称为堆，需要手动释放
    sizeof计算一个int型变量占内存多少单元
    (int *)将指针指向的数据强制转换为整型 */
    st.head = (int *)malloc(Size * sizeof(int));
    if (!st.head)
    {
        printf("没有分配内存");
        exit(0);
    }
    st.size = Size;
    st.length = 0;
    return st;
}

int main()
{
    // 初始化顺序素
    ST st = initST();
    for (int i = 1; i <= Size; i++)
    {
        st.head[i - 1] = i;
        st.length++;
    }

    // 求表长
    int l;
    l = lengthST(st);
    printf("顺序表长%d\n", l);

    // 打印元素
    printf("打印初始化的顺序表\n");
    printST(st);

    // 插入元素
    st = insertST(st, 1, 6);
    printf("打印插入元素后的顺序表\n");
    printST(st);

    // 删除元素
    st = deleteST(st, 1);
    printf("打印删除元素后的顺序表\n");
    printST(st);

    // 按值找位
    int e = 9;
    int idx;
    idx = locateelementST(st, e);
    if (idx)
    {
        printf("查询元素%d在的顺序表的序位是%d\n", e, idx);
    }
    else
    {
        printf("查询元素%d不在的顺序表\n", e);
    }

    // 按位找值
    e = getelementST(st, idx = 4);
    printf("顺序表位序%d的元素是%d\n", idx, e);

    // 判空
    bool flag;
    flag = emptyST(st);
    if (flag)
    {
        printf("顺序表是空的\n");
    }
    else
    {
        printf("顺序表不是空的\n");
    }

    // 销毁
    destroyST(st);

    return 0;
}

int lengthST(ST st)
{
    int e = st.length;
    return e;
}

void printST(ST st)
{
    for (int i = 0; i < st.length; i++)
    {
        int print = st.head[i];
        printf("打印第%d的值是:%d\n", i, print);
    }
    printf("\n");
}

ST insertST(ST st, int idx, int elem)
{
    if ((idx < 0) || (idx > st.length + 1))
    {
        printf("插入位置有问题\n");
        return st;
    }
    if (st.length == st.size)
    {
        st.head = (int *)realloc(st.head, (st.size + 1) * sizeof(int));
        if (!st.head)
        {
            printf("没有头指针存储空间分配失败\n");
            return st;
        }
        st.size += 1;
    }
    for (int i = st.length - 1; i >= idx - 1; i--)
    {
        st.head[i + 1] = st.head[i];
    }
    st.head[idx - 1] = elem;
    printf("出入元素%d\n", elem);
    st.length++;
    return st;
}

ST deleteST(ST st, int idx)
{
    if ((idx < 0) || (idx > st.length))
    {
        printf("删除位置有问题\n");
        return st;
    }
    int elem = st.head[idx - 1];
    printf("删除元素%d\n", elem);
    for (int j = idx; j < st.length; j++)
    {
        st.head[j - 1] = st.head[j];
    }
    st.length -= 1;
    st.head = (int *)realloc(st.head, (st.size - 1) * sizeof(int));
    st.size -= 1;
    return st;
}

bool locateelementST(ST st, int elem)
{
    for (int i = 0; i < st.length; i++)
    {
        if (st.head[i] == elem)
        {
            return i + 1;
        }
    }
    return false;
}

int getelementST(ST st, int idx)
{
    int e = st.head[idx];
    return e;
}

bool emptyST(ST st)
{
    if (st.length == 0)
    {
        return true;
    }
    return false;
}

bool destroyST(ST st)
{
    free(st.head);
    st.head = NULL;
    return true;
}
```



#### **顺序表的插入**

**算法思路**

- **判断插入结点位置是否满足顺序表定义**
- **判断存储空间是否已达上限，是则扩充存储空间**
- **将插入结点位置到表尾的结点分别向后移动一位**
- **腾出的存储空间插入数据元素并调整表长属性**

```c
// 找到插入位置，插入位置之后的元素往后移，给插入元素腾地方
ST addST(ST st, int idx, int elem)
{
    // 边界条件1[插入的位置不能是最后一个位置的后两个位置]
    if ((idx < 0) || (idx > st.length + 1))
    {
        printf("插入位置有问题\n");
        return st;
    }
    // 边界条件2[如果t.length==t.size意味着，内存空间已经满了，需要开辟新的空间]
    if (st.length == st.size)
    {
        // 这里函数realloc重新分配存储空间，参数是需要扩充的头指针与扩充之后的总的大小
        st.head = (int *)realloc(st.head, (st.size + 1) * sizeof(int));
        if (!st.head)
        {
            printf("没有头指针存储空间分配失败\n");
            return st;
        }
        st.size += 1;
    }
    // 后挪腾出存储空间并插入
    for (int i = st.length - 1; i >= idx - 1; i--)
    {
        st.head[i + 1] = st.head[i];
    }
    st.head[idx - 1] = elem;
    printf("出入元素%d\n", elem);
    st.length++;
    return st;
}
```



**时间复杂度**

- **「最好情况」在表尾插入结点，结点后移语句将执行 $0$ 次，时间复杂度为 $O(1)$**

- **「最坏情况」在表头插入结点，结点后移语句将执行 $n$ 次，时间复杂度为 $O(n)$**

- **「平均情况」在长度为 $n$ 的线性表中插入一个结点所需移动结点的平均次数为 $\sum_{i=1}^{n+1}\frac{1}{n+1}(n-i+1)=\frac{n}{2}$，时间复杂度为 $O(n)$**



#### **顺序表的删除**

**算法思路**

- **判断删除结点位置是否满足顺序表定义**
- **获取删除结点的数据元素**
- **将被删结点后面的所有元素都依次向前移动一个结点并调整表长属性**

```c
// 找到删除位置，把其后的元素往后前
ST deleteST(ST st, int idx)
{
    // 边界条件1[删除的位置不能超出表的范围]
    if ((idx < 0) || (idx > st.length))
    {
        printf("删除位置有问题\n");
        return st;
    }
    // 取出删除元素，并把其后的元素前移
    int elem = st.head[idx - 1];
    printf("删除元素%d\n", elem);
    for (int j = idx; j < st.length; j++)
    {
        st.head[j - 1] = st.head[j];
    }
  	// 重新表长属性
    st.length -= 1;
  	/* 如需调整存储空间则执行
       st.head = (int *)realloc(st.head, (st.length) * sizeof(int));
       st.size -= 1; */
    return st;
}
```



**时间复杂度**

- **「最好情况」删除表尾结点，无须移动结点，时间复杂度为 $O(1)$**
- **「最坏情况」删除表头结点，需要移动除第一个元素外的所有结点，时间复杂度为 $O(n)$**
- **「平均情况」在长度为 $n$ 的线性表中删除一个结点所需移动结点的平均次数为 $\sum_{i=1}^{n}\frac{1}{n}(n-i+1)=\frac{n-1}{2}$，时间复杂度为 $O(n)$**





### **链表**

**链表是链式存储结构的线性表**



#### **单链表**

**线性表的链式存储又称单链表，通过一组任意的存储单元来存储线性表中的数据元素。每个链表结点除存放数据元素自身外，还存放一个指向其后继的指针，建立数据元素之间的线性关系**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329154732443.png" alt="image-20220329154732443" width="250px;" />



```c
/* 定义单链表结点类型，结点是一个结构类型struct ListNode，
	 有两个数据项，一个是整型data，另一个指针next
	 其中的指针是指向同样的结构类型的数据元素
	 这种类型是又包括两个成员的指针，嵌套定义即自己来定义自己 
	 式typrdef struct ListNode [...] LNode, *Linklist;是 
	 将[...]规则定义的结构体ListNode取名LNode
	 typedef struct ListNode [...] LNode;
	 将[...]规则定义的结构体ListNode的指针取名LinkList用于定义指针
   typedef struct ListNode [...] *LinkList; */
typedef struct ListNode
{
  // 数据域
  int data;
  // 指针域
  struct ListNode *next;
}LNode, *LinkList;
```



**单链表解决了顺序表需要大量地址连续的存储空间的缺点，但单链表附加指针域，也存在浪费存储空间的缺点。由于单链表的数据元素离散地分布在存储空间中，所以单链表是非随机存取的存储结构，即不能直接找到表中某个特定的结点。查找某个特定的结点时，需要从表头开始遍历，依次查找**

- **用头指针来标识一个单链表**

  > **单链表 $L$，头指针为 $NULL$ 时表示一个空表。为了操作上的方便可在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长等信息。头结点的指针域指向单链表的第一个结点，头指针始终指向链表的第一个结点（头结点是带头结点链表中的第一个结点）**

  

  <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329105204542.png" alt="image-20220329105204542" width="550px;" />

  

- **引入头结点可以带来两个优点**

  > **使得在第一元素结点前插入结点与删除第一结点等操作与其它结点的操作统一**
  >
  > **无论链表是否为空，其头指针是指向头结点的非空指针，空表和非空表的操作统一**



##### **头插法建立单链表**

**建立新的结点分配内存空间，将新结点插入到当前单链表作为第一个结点，时间复杂度为 $O(n)$**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%AA%E5%B1%8F2022-03-29%2010.59.10.png" alt="截屏2022-03-29 10.59.10" width="450px;" />



```c
// 逆向建立单链表
LinkList List HeadInsert(IinkList &L)
{
    LNode *S;  // 等价于struct ListNode *S
    int x;
    // 创建头结点其数据元素是指针而该指针指向的是定义的结构类型的数据元素
    L = (LinkList)malloc(sizeof(LNode));
    // 初始为空链表
    L->next = NULL;
    // 输入结点的值
    scanf("%d", &x);
    while (x != 9999)
    {
        // 创建新结点
        S = (LNode *)mal1oc(sizeof(LNode));
        S->data = x;
        S->next = L->next;
        // 将新结点插入表中L为头指针
        L->next = S;
        scanf("%d", &x);
    }
    return L;
}
```



##### **尾插法建立单链表**

**建立新的结点并分配内存空间，将新结点插入到当前链表的表尾，使得读入数据的顺序和单链表中结点的顺序一致，因此需要增加一个尾指针 $r$ 使其始终指向当前单链表的尾结点，时间复杂度为 $O(n)$**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%AA%E5%B1%8F2022-03-29%2011.02.06.png" alt="截屏2022-03-29 11.02.06" width="500px;" />



```c
// 正向建立单链表
LinkList List TailInsert(IinkList &I)
{
  	// r为表尾指针
    LNode *S, *r = L;
	  // 输入结点的值
    scanf("%d", &x);  
    while (x != 9999)
    {
        S = (LNode *)malloc(sizeof(LNode));
        S->data = x;
        r->next = S;
      	// 指向新的表尾结点
        r = S;
        scanf("%d", &x);
    }
  	// 尾结点指针置空
    r->next = NULL;
    return L;   
}
```



##### **按序号查找结点**

**从单链表的第一个结点开始，顺指针域 $next$ 逐个往下搜索，直到找到第 $i$ 个结点为止，否则返回最后一个结点指针域 $NULL$，时间复杂度为 $O(n)$**

```c
LNode *GetElem(LinkList L, int i)
{
    int j = 1;
    LNode *p = L->next;
    if (i == 0)
        return L;
    if (i < 1)
        return NULL;
    while (p && j < i)
    {
        p = p->next;
        j++;
    }
    return p;
}
```



##### **按值查找结点**

**从单链表第一个结点开始，由前往后依次比较表中各结点数据域的数据元素，若某结点数据域的数据元素等于给定的 $e$，则返回该结点的指针，若整个单链表中没有这样的结点，则返回 $NULL$，时间复杂度为 $O(n)$**

```c
LNode *LocateElem(LinkList L, int e)
{
    LNode *p = L->next;
    while (p !=NUIL && p->data != e)
            p = p->next;
    return p;
}
```



##### **插入操作**

**将值为 $x$ 的新结点 $*s$ 插入到单链表的第 $i$ 个位置上。首先检查插入位置的合法性，然后找到待插入位置的前驱结点 $*p$，再在第 $i−1$ 个结点后插入新结点，时间复杂度为 $O(n)$**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%AA%E5%B1%8F2022-03-29%2015.57.37.png" alt="截屏2022-03-29 11.02.06" width="500px;" />



* **查找指向插入位置的前驱结点的指针**

  > `p=GetElem(L,i-1);`

* **令新结点 $*s$ 的指针域指向 $p$ 的后继结点**

  > `s->next=p->next;`

* **令结点 $p$ 的指针域指向新插入的结点 $*s$**

  > `p->next=s;` 

- **一种特殊方式是直接在将新结点插入到单链表的第 $i$ 个结点后作为第 $i+1$ 个结点，然后直接交换两个结点的数据，节省了查找第 $i$ 个结点的前驱第 $i-1$ 个结点的时间，时间复杂度为 $O(1)$**



##### **删除操作**

**将单链表的第 $i$ 个结点 $*q$ 删除。首先检查删除位置的合法性，然后查找表中第 $i−1$ 个结点即被删结点的前驱结点 $*p$ ，修改 $a$ 指向 $c$ 后再将结点 $*q$ 删除，时间复杂度为 $O(n)$**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%AA%E5%B1%8F2022-03-29%2015.56.21.png" alt="image-20220329155702031" width="400px;" />



- **查找删除位置的前驱结点的指针** 

  > `p=GetElem(L,i-1);`

- **取指向删除位置的指针** 

  > `q=p->next;`

- **令 $p$ 指向被删除结点的后继** 

  > `p->next=q->next`

- **释放删除结点** 

  > `free(q);`

- **一种特殊方式是直接交换单链表的第 $i$ 个结点与后继结点的数据，然后令第 $i$ 个结点指向后继结点的后继结点再直接删除第 $i$ 个结点的后继结点，节省了查找第 $i$ 个结点的前驱第 $i-1$ 个结点的时间，时间复杂度为 $O(1)$**



##### **求表长操作**

**计算单链表中数据结点 （不含头结点）的个数，需要从第一个结点开始顺序依次访问表中的每个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加 $1$，直到访问到空结点为止，算法的时间复杂度为 $O(n)$**



#### **双链表**

**单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。插入与删除操作时需要访问某个结点的前驱结点，就只能从头开始遍历，访问后继结点的时间复杂度为 $O(1)$ 而访问前驱结点的时间复杂度则为 $O(n)$**

**为了克服单链表的上述缺点引入了双链表，双链表结点中有两个指针 $prior$ 和 $next$，分别指向其前驱结点和后继结点**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329154939708.png" alt="image-20220329154939708" width="700px;" />



**建立双链表同样有头插法与尾插法两种**



##### **插入操作**

**在双链表中 $p$ 所指的结点之后插入值为 $x$ 的新结点 $*s$**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329163401681.png" alt="image-20220329163401681" width="450px;" />



- `1. s->next=p->next;`
- `2. p->next->prior=s;`
- `3. s->prior=p;`
- `4. p->next=s;`



##### **删除操作**

**删除双链表中 $*p$ 的后继结点 $*q$ 并 $free(q)$**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329164428796.png" alt="image-20220329164428796" width="500px;" />



- `1. p->next=q->next;`
- `2. q->next->prior=p;`



#### **循环链表**

**循环单链表和单链表的区别在于，表中最后一个结点的指针不是 $NULL$，而是指向头结点，从而整个链表形成一个环**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329164940206.png" alt="image-20220329164940206" width="650px;" />



**循环双链表类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环，当循环双链表为空表时，其头结点的指针域 $prior$ 和指针域 $next$ 都等于头结点的指针**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329165103810.png" alt="image-20220329165103810" width="700px;" />



#### **静态链表**

**静态链表是用数组来描述线性表的链式存储结构，数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标，静态链表最后一个元素的指针域值为 $-1$**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329165430282.png" alt="image-20220329165430282" width="200px;" />



- **从数组的第一个数据元素开始 $a$ 指向 $b$ 指向 $c$ 指向 $d$ 结束**
- **静态链表是通过顺序存储结构来模拟链式存储结构的特殊情形，通常用于不支持指针的高级语言，从这点不难发现链表相对顺序表更难实现，因为任何高级语言中都有数组类型而链表只存在于支持指针的高级语言中**







## **受限线性表与线性表推广**

**主要是受限线性表的栈、队列、串以及线性表推广的数组等**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%AA%E5%B1%8F2022-04-01%2010.06.59.png" alt="image-20220329171125621" width="500px;" />



### **栈**

**栈是一种只允许在一端进行插入或删除操作的线性表**

* **栈顶**

    > *不固定，线性表允许进行插入和删除的那一端指向最上层的数据元素* 

* **栈底**

    > *固定，不允许进行插入和删除的另一端* 

- **栈顶指针**

  > **初始时 $*s.top=0$ 指向栈顶元素的下一个存储单元，栈顶元素 $*(s.top-1)$** 

- **进栈操作**

  > **栈不满时将数据元素赋给栈顶元素 $*s.top=e$，然后上移栈顶指针 $s.top+1$**

- **出栈操作**

  > **栈非空时将取出栈顶元素 $*(s.top-1)$，然后下移栈顶指针 $s.top-1$**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329172532935.png" alt="image-20220329172532935" width="250px;" />



**栈的特点是受限的线性表，所以自然具有线性关系；栈中数据元素后进去的必然先出来，即后进先出**



#### **顺序栈**

**栈的顺序存储结构也叫作顺序栈，是线性表顺序存储的简化，其主要操作有**

- **`Initstack(&S)` 初始化一个空栈 $S$**
- **`stackEmpty(S)` 判断一个栈是否为空，若栈 $S$ 为空则返回 $true$，否则返回 $false$**
- **`Push(&S,x)` 进栈，若栈 $S$ 未满，则将 $x$ 加入使之成为新栈顶**
- **`Pop(&S,&x)` 出栈，若栈 $S$ 非空，则弹出栈顶元素，并用 $x$ 返回**
- **`GetTop(S,&x)` 读栈顶元素，若栈 $S$ 非空，则用 $x$ 返回栈顶元素**
- **`Destroystack(&S)` 销毁栈，并释放栈 $S$ 占用的存储空间**



##### **顺序栈的实例**

```cpp
#include <stdio.h>
#include <stdlib.h>
#define STACK_INIT_SIZE 100
#define STACKINCREATEMENT 10
#define OK 1
#define ERROR 0
#define OVERFLOW -2

typedef int status;
typedef struct stack
{
    int *base;
    int *top;
    int stacksize;
} sqstack;

// 传入顺序栈的引用参数初始化
status initstack(sqstack &s)
{
    s.base = (int *)malloc(STACK_INIT_SIZE * sizeof(int));
    if (!s.base)
        exit(OVERFLOW);
    s.top = s.base;
    s.stacksize = STACK_INIT_SIZE;
    return OK;
}

// 入栈
status push(sqstack &s, int e)
{
    // 栈满
    if (s.top - s.base >= s.stacksize)
    {
        s.base = (int *)realloc(s.base, (s.stacksize + STACKINCREATEMENT) * sizeof(int));

        if (!s.base)
            exit(OVERFLOW);

        s.top = s.base + s.stacksize;
        s.stacksize = s.stacksize + STACKINCREATEMENT;
    }

    *s.top = e;
    s.top++;
    return OK;
}

// 出栈
status pop(sqstack &s, int &e)
{
    // 栈空
    if (s.base == s.top)
        return ERROR;

    // 取出栈顶元素
    e = *(s.top - 1);
    // 指针top减一
    s.top--;
    return OK;
}

// 获取栈顶元素
status gettop(sqstack &s, int &e)
{
    if (s.base == s.top)
        return ERROR;
    e = *(s.top - 1);
    return OK;
}

// 打印栈中数据元素
status printstack(sqstack s)
{
    if (s.base == s.top)
    {
        printf("空栈\n");
        return ERROR;
    }
    else
        printf("栈的内容为:");

    for (s.base; s.base != s.top; s.base++)
    {
        printf("%d  ", *s.base);
    }

    return OK;
}

int main()
{
    sqstack s;
    int x = 1;
    initstack(s);

    while (1)
    {
        printf("请输入要进行的操作:\n");
        printf(" 1.进栈\n 2.出栈\n 3.获取栈顶元素\n 4.打印\n 0.退出\n");
        scanf("%d", &x);
        if (x == 0)
            break;
        switch (x)
        {
        case 0:
            free(s.base);
            s.base = NULL;
            break;
        case 1:
            int pushnumber;
            printf("请输入要进栈的元素:");
            scanf("%d", &pushnumber);
            if (push(s, pushnumber))
                printf("进栈成功\n");
            else
                printf("进栈失败\n");
            break;
        case 2:
            int e;
            if (pop(s, e))
                printf("元素%d出栈\n", e);
            else
                printf("出栈失败\n");
            break;
        case 3:
            if (gettop(s, e))
                printf("栈顶元素是:%d\n", e);
            else
                printf("获取栈顶元素失败\n");
            break;
        case 4:
            if (printstack(s))
                printf("打印完毕\n");
            break;
        default:
            printf("您进行了误操作，请重试\n");
            break;
        }
    }
    return 1;
}
```



#### **共享栈**

**利用栈底位置相对不变的特性让两个顺序栈共享一个一维数组的特殊顺序栈，将两个栈底分别设置为共享空间的两端，两个栈顶则向共享空间的中心延伸。顺序栈的存储空间大小需要事先开辟好而很多空间难以利用到，使用共享栈就可以提高存储空间的利用率**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329173440765.png" alt="image-20220329173440765" width="500px;" />



#### **链栈**

**栈的链式存储结构也叫做链栈，是线性表顺序存储的简化，链栈一般不存在栈满的情况而空栈的判定条件通常定为 $top==NULL$**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329173331346.png" alt="image-20220329173331346" width="600px;" />



#### **栈的应用**

**栈可以应用于括号匹配、表达式求值和优化递归等方面**



##### **括号匹配**

**假设有两种括号，一种圆的 $()$，一种方的 $[]$，允许任意顺序成对匹配嵌套，如 $([])$ 或 $[([][])]$ 等是括号匹配的**

- **算法思想**

  > *顺序读入括号字符串* 
  >
  > *若是左括号，入栈* 
  >
  > *若是右括号，出栈一个左括号并检验是否与之匹配* 
  >
  > *检验到括号字符串尾都匹配且栈空，则整个括号字符串是括号匹配的* 



##### **表达式求值**

**先将表达式（自然的中缀表达式）转换成后缀表达式（规则是先按运算符优先级对所有运算符和它的运算数加括号；然后把运算符移到对应的括号后；最后去掉括号），从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就连续出栈两个数字然后跟这个符号进行运算并将运算结果进栈，直到获得最终结果**



##### **优化递归**

**在一个函数、过程或数据结构的定义中又应用了它自身，那么这个函数、过程或数据结构就称为是递归定义的**

**递归可以把一个的复杂问题转化为一个与原问题相似而规模较小的问题，递归最重要的是递归式即递归体与递归边界即递归出口，递归可以用少量代码描述出解题过程需要重复多次的计算，但是递归的时间复杂度相对较高，通过栈可以把递归转化为非递归问题从而减小时间复杂度**

**在阶乘中运用递归计算，时间复杂度为 $O(n)$**

```c
int func(int n)
{
  if(n==0) return 1;
  else return n*func(n-1);
}
```



**通过栈同样可以实现阶乘其时间复杂度为 $O(n)$**

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <stack>
using namespace std;

int main()
{
  int m = 4;
  int n = 1;
  stack<int> s;
  while (m--)
  {
    s.push(1);
    int sum = 1;
    for (int i = 1; i <= n; i++)
    {
      sum = i * s.top();
      s.push(sum);
    }
    printf("%d\n", s.top());
    n++;
    while (!s.empty())
      s.pop();
  }
}
```



**在计算斐波那契数列 $fib(n)$ 中运用递归计算，时间复杂度为 $O(2^n)$**
$$
fib(n)=\begin{cases}
fib(n-1)+fib(n-2)\quad&n>1\\
1\quad&n=1\\
0\quad&n=0
\end{cases}
$$

```c
int fib(int n)
{
  if(n==0) return 0;
  else if(n==1) return 1;
  else return fib(n-1)+fib(n-2);
}
```



**递归实现的斐波那契数列代码可读性高，但是计算过程中会存在大量重复，例如 $fi b(5)=fib(4)+fib(3),fib(4)=fib(3)+fib(2)$ 两个递归就产生了相同的 $fib(3)$，实际上计算 $fib(5)$ 只需要计算出 $fib(4),fib(3),fib(2),fib(1)$，因此先将 $fib(4)\rightarrow fib(1)$ 递归的路径压入栈中再按照 $fib(1)\rightarrow fib(4)$ 的路径依次弹出计算即可** 

```cpp
#include <iostream>
#include <stack>
using namespace std;

long fib(int n, stack<int *> &S)
{
    long result = 0;
    S.push(new int(n));
    while (S.empty() == false)
    {
        int *top = S.top();
        S.pop();
        if (*top <= 1)
        {
            result += 1;
        }
        else
        {
            S.push(new int(*top - 1));
            S.push(new int(*top - 2));
        }
        delete top;
    }
    return result;
}

int main()
{
    stack<int *> st;
    cout << "第5个斐波拉契数是:" << fib(4, st);
}
```





### **队列**

**队列是只允许在一端进行插入，而在另一端进行删除的线性表，先进入队列的数据元素必然先离开队列，即先进先出**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329175331548.png" alt="image-20220329175331548" width="400px;" />



* **队头**

    > *又称为队首允许删除的一端* 

* **队尾**

    > *允许插入的一端* 



#### **顺序队列**

**顺序存储结构的队列，分配一块连续的存储空间存放队列中的元素并通过附设两个指针队头指针 $front$ 与队尾指针 $rear$ 描述相对顺序，使 $front$ 指向队头元素而 $rear$ 指向队尾元素来实现出队入队的操作**

- **初始状态**

  > `front==rear==0`

- **入队操作**

  > *队不满时，先送值到队尾元素，再将队尾指针加 $1$*

- **出队操作**

  > *队不空时，先取队头元素值，再将队头指针加 $1$*



#### **循环队列**

**臆造一个环形的顺序存储空间。当队首指针 $front=MaxSize-1$ 时再前进一个位置就自动到 $0$，这样首尾相连的顺序存储的队列就叫循环队列**

* **入队操作**

    > `rear=(rear+1)%MaxSize`

* **出队操作**

    > `front=(front+1)%MaxSize`

- **分辨循环队列是空还是满的可以设置标志位 $flag$，当 $flag=0$ 且 $rear$ 等于 $front$ 时为队列空，当 $flag=1$ 且 $rear$ 等于 $front$ 时为队列满；也可以令存储空间中保留一个空存储单元，用 $front=rear$ 作为队空的判定条件**



#### **链式队列**

**链式存储结构的队列，本质上是只能表尾插入数据元素，表头删除数据元素的单链表分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329202655656.png" alt="image-20220329202655656" width="450px;" />



* **入队操作**

  > *入队就是在队尾指针进行插入结点操作。链式队列的插入操作和单链表的插入操作是一致的* 

* **出队操作**

  > *出队就是头结点的后继结点出队，然后将头结点的后继改为头结点的后继的后继* 



#### **双端队列**

**队列的两端称为前端与后端，两端都可以进行入队和出队操作的队列**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220329202748709.png" alt="image-20220329202748709" width="500px;" />



**双端队列进队时，前端进的数据元素排列在队列中后端进的元素前面，后端进的数据元素排列在前端进的数据元素的后面，出队时无论前端还是后端出队，先出的数据元素都排列在后出的数据元素的前面**

**允许在一端进行插入和删除，但在另一端只允许插入的双端队列叫做输出受限的双端队列，允许在一端进行插入和删除，但在另一端只允许删除的双端队列叫做输入受限的双端队列**



#### **队列的应用**

**队列可以应用在需要逐层或逐行的信息处理。这类问题的解决方法往往是在处理当前层或当前行时就对下一层或下一行做预处理，把处理顺序安排好，等到当前层或当前行处理完毕，就可以处理下一层或下一行**



##### **处理 CPU 的资源的竞争**

**在一个带有多终端的计算机系统上，有多个用户需要 CPU 各自运行自己的程序，它们分别通过各自的终端向操作系统提出占用 CPU 的请求。操作系统通常按照每个请求在时间上的先后顺序，把它们排成一个队列，每次把 CPU 分配给队首请求的用户使用。当相应的程序运行结朿或用完规定的时间间隔后，令其出队，再把 CPU 分配给新的队首请求的用户使用。这样既能满足每个用户的请求，又使CPU 能够正常运行**





### **串**

**计算机上非数值处理的对象基本都是字符串数据。我们常见的信息检索系统(如搜索引擎）、文本编辑程序（如 Word）、问答系统、自然语言翻译系统等，都是以字符串数据为处理对象；字符串数据即串是由零个或多个字符组成的有限序列 $S='a_1a_2\cdots a_n'(n\geq0)$ 其中 $a_i$ 可以是字母、数字或其他字符，$n=0$ 的串称为空串 $\varnothing$；串中任意多个连续的宇符组成的子序列称为该串的子串，某个字符在串中的序号称为该字符在串中的位置，当两个串的长度相等且每个对应位置的宇符都相等时，称这两个串是相等的**



#### **串的逻辑结构**

**串的逻辑结构与线性表极为相似，区别仅在于串的数据对象限定为字符集。在基本操作上，串和线性表有很大差别。线性表的基本操作主要以单个数据元素作为操作对象，如查找、插入或删除某个元素等；而串的基本操作通常以子串作为操作对象，如查找、插入或删除一个子串等**



#### **串的存储结构**

**串的存储结构有定长顾序存储、堆分配存储和块链存储等**



##### **定长顺序存储**

**类似线性表的顺序存储结构，用一组地址连续的存储空间记录串的字符序列；在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组**

```c
#define MAXLEN 255
typedef struct
{
    // 每个分量存储一个字符
    char ch[MAXLEN];
    // 串的实际长度
    int length;
} SString;
SString ss;
```



##### **堆分配顺序存储**

**仍然以一组地址连续的存储单元存放串值的宇符序列，但它们的存储空间是在程序执行过程中动态分配得到的，称为堆空间但并非指数据结构为堆，仅因为该内存空间需要手动释放**

```c
#define INIT_SIZE 10
typedef struct
{
    char *ch;
    int length;
} HString;
HString hs;
hs.ch = (char *)malloc(NIT_SIZE * sizeof(char));
```



##### **块链存储**

**类似于线性表的链式存储结构，也可采用链表方式存储串值；由于串的特殊性在具体实现时，每个结点既可以存放一个字符，也可以存放多个字符，每个结点称为块，整个链表称为块链结构**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220330113817384.png" alt="image-20220330113817384" width="400px;" />

<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220330113727863.png" alt="image-20220330113727863" width="550px;" />



#### **串的主要操作**

- **`strAssign(&T,chars)` 赋值操作；将串 $T$ 赋值为 $chars$** 
- **`strcopy(&T,S)` 复制操作；将串 $S$ 复制为 $T$**  
- **`StrEmpty(S)` 判空操作；若 $S$ 为空串则返回 $true$ 否则返回 $false$**
- **`strcompare(S,T)` 比较操作；若 $S>T$ 则返回值 $>0$；若 $S=T$ 则返回值 $=0$；若 $S<T$ 则返回值 $<0$**
- **`StrLength(S)` 求串长。返回串 $S$ 的元素个数**
- **`Substring(&Sub,s,pos,1en)` 求子串；用 $sub$ 返回串 $S$ 的第 $pos$ 个字符起长度为 $len$ 的子串**
- **`concat(&T,S1,S2)` 串联接；用 $T$ 返回由 $S1$ 和 $S2$ 联接而成的新串**
- **`Index(S,T)` 定位匹配操作；若主串 $S$ 中存在与串 $T$ 值相同的子串，则返回它在主串 $S$ 中第一次出现的位置，否则函数值为 $0$，也称为串的模式匹配**
- **`Clearstring(&S)` 清空操作；将 $S$ 清为空串**
- **`Destroystring(&S)` 销毀串；将串 $S$ 销毁**

**在 $C$ 语言中，$char$ 是不可变数据类型，因此需要在定义字符变量或字符数组时完成变量的初始化，但是也可使用 $strcpy$ 函数进行修改**



##### **暴力匹配算法**

```c
/* 从头到尾依次比字符串元素来进行模式匹配，不匹配则回溯并从一开始比对元素的后继开始重复这一过程，时间复杂度为O(m*n) */
int BFIndex(SString sm, SString sp)
{
    int i = 0; // 主串的匹配起始位置
    int j = 0; // 模式串的匹配起始位置

    while (i < sm.length && j < sp.length)
    {
        if (sm.ch[i] == sp.ch[j])
        {
            ++i; // 当前字符匹配成功，两者均往后走一个位置
            ++j;
        }
        else
        {
            i = i - j + 1; // 每次未匹配成功时i回退到原来i的后一位置
            j = 0;         // 模式串每次未匹配成功时回退到0位置
        }
    }
    if (j >= sp.length) // 条件满足说明j走过了模式串的所有字符
    {
        return i - j;
    }
    return -1;
}
```



##### **KMP（Knuth-Morris-Pratt）算法**

```c
/* KMP改进了回溯后继续比对的开始结点选择问题，匹配过程中主串字符指针不往回退，只需要移动模式串的指针j即可，时间复杂度为O(m+n)
1. next背景知识
单独用一个转移数组next计算出模式串t的各字符的转移数
不存在相同的最长前缀和最长后缀时next[k]=0
前缀是说以第一个字符开始，但是不包含最后一个字符的子串
后缀是说以最后一个字符开始，但是不包含第一个字符的子串
abcbc，前缀为[a,ab,abc,abcb]后缀为[c,bc,cbc,bcbc]没有相同的前缀和后缀，相应next值为0
cbcbc，最长前缀和最长后缀相同是cbc，相应next值为3
abcjkdabc，那么这个数组的最长前缀和最长后缀相同必然是abc，相应next值为3

2. 计算next数组
next[r]的含义是t的子串t[0~r-1]相同的最长前缀和最长后缀的长度
可设置next[0]=-1作为转移数组的起始值，因此next的长度为t的长度加一
首先可知t[0]的next[1]必定为0，因此还需得到next[2~k]的转移数
分析可知t的子串中t[0~r-1]的最长前后缀相同是t[0~r]的子问题
可设置一个前缀指针j=0和一个后缀指针i=1
可设置回溯条件t[i]=t[j]满足则指针自增令next[i]=j，若不能满足就令前缀指针j=next[j]，因为t[0~i]的子问题已经表明前缀与后缀相同长度至少是j

3. 计算匹配位置
给主串s一个指针i模式串t一个指针j，逐字符匹配，利用之前已经部分匹配这个有效信息
如果j = -1，或者当前字符匹配成功（即sm[i] == sp[j]），都令i++，j++
如果j != -1，当模式串t的第k个字符与主串s匹配时失配时，则令 i 不变，j = next[j]，等价于模式串向后移动k-next[k] */

void GetNext(SString sp, int *next)
{
    int i = 1;
    int j = 0;
    next[0] = -1;
    next[1] = 0;

    while (i < sp.length)
    {
        if (j == -1 || sp.ch[i] == sp.ch[j])
        {
            ++i;
            ++j;
            next[i] = j;
        }
        else
        {
            j = next[j];
        }
    }
}

int KMPIndex(SString sm, SString sp)
{
    int i = 0;
    int j = 0;
    int *next = (int *)malloc(sizeof(int) * sp.length);
    GetNext(sp, next);
    while (i < sm.length && j < sp.length)
    {
        if (j == -1 || sm.ch[i] == sp.ch[j])
        {
            ++i;
            ++j;
        }
        else
        {   
            j = next[j];
        }
    }
    if (j >= sp.length)
    {
        return i - j;
    }
    return -1;
}
```





### **数组**

**数组是由 $n(n≥1)$ 个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组元素，每个数据元素在 $n$ 个线性关系中的序号称为该数据元素的下标，下标的取值范围称为数组的维界**

**数组是线性表的推广，一维数组可视为一个线性表；二维数组可视为其元素也是定长线性表的线性表，以此类推。**

**数组一旦被定义，其维数和维界就不再改变。因此除数组的初始化和销毁外，数组只会有存取元素和修改元素的操作**



#### **数组的映射**

**计算机内存器的结构是一维的，因此对于一维数组按下标依序映射即可。多维数组有两种映射方法，按行优先和按列优先。以二维数组为例，按行优先存储的基本思想是先行后列，先存储行号较小的数据元素，行号相等先存储列号较小的数据元素；按列优先时先列后行，先存储列号较小的数据元素，列号相等先存储行号较小的数据元素**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220330043047325.png" alt="image-20220330043047325" width="500px;" />



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220330043112470.png" alt="image-20220330043112470" width="500px;" />



#### **数组的压缩**

**多维数组即矩阵可以通过给多个数据元素相同的结点分配同一个存储空间，零数据元素不分配空间，归纳特殊的矩阵中非零数据元素的分布规律来降低空间复杂度**

**稀疏矩阵（矩阵的阶为 $100×100$ 而矩阵中只有不到 $100$ 个非零元素）非零数据元素的分布没有规律，若采用常规的方法存储稀疏矩阵，则相当浪费存储空间，因此将非零元素、相应的行和列构成一个三元组（行标，列标，值）从前往后存储这些三元组可压缩存储空间，但是失去了数组作为顺序表的随机存取特性。**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220330044810620.png" alt="image-20220330044810620" width="500px;" />







## **集合**

**集合是数据元素不重复的、无序的数据结构。不包含数据元素的集合称为空集，两个集合的成员完全相同称两个集合相等，一个集合中所有的成员都属于另外一个集合，则前一集合称为后一集合的子集，其主要操作有**

- **`add()` 将一个数据元素添加到集合中**
- **`has()` 判断一个数据元素是否存在于集合中**
- **`delete()` 删除集合中的某个数据元素**
- **`clear()` 清空集合内的所有数据元素**
- **`size()` 返回集合内的数据元素个数**
- **`values()` 返回集合内的所有数据元素**
- **`union()` 获取与另一个集合的并集**
- **`intersect()` 获取与另一个集合的交集**
- **`difference()` 获取与另一个集合的差集**
- **`subset()` 判断是否为另一个集合的子集**







## **树形结构**

**树形结构是层次的嵌套结构，一个树形结构的外层和内层有相似的结构， 所以这种结构多可以递归的表示。数据元素之间存在着一对多的树形关系的数据结构，多棵树的集合是森林，树形结构中最简单最重要的是二叉树**



### **一般树**

**一般树即树是 $n\;(n\geq0)$ 个结点的有限集。当 $n=0$ 时，称为空树；任意一棵非空树有且仅有一个特定的称为根的结点，当 $n>1$ 时，其余结点可分为 $m\;(m>0)$ 个互不相交的有限集 $T_1,T_2,\cdots,T_m$，其中每个集合本身又是一棵树，并且称为根的子树**

**树的定义是递归的（树的定义中又用到了其自身）即树是递归的数据结构。树是一种非线性逻辑结构，根结点没有前驱，除根结点外的所有结点有且只有一个前驱，树中所有结点可以有零个或多个后继**

**树适合表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个结点（即父结点）有直接关系，根结点没有直接上层结点，因此在 $n$ 个结点的树中有 $n-1$ 条边。而树中每个结点与其下一层的零个或多个结点（其子结点）有直接关系**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220412175623198.png" alt="image-20220412175623198" width="500px;" />



- **考虑结点 $K$ 。根 $A$ 到结点 $K$ 的唯一路径上的任意结点，称为结点 $K$ 的祖先。如结点 $B$ 是结点 $K$ 的祖先，而结点 $K$ 是结点 $B$ 的子孙。路径上最接近结点 $K$ 的结点 $E$ 称为 $K$ 的双亲，而 $K$ 为结点 $E$ 的孩子。根 $A$ 是树中唯一没有双亲的结点。有相同双亲的结点称为兄弟，如结点 $K$ 和结点 $L$ 有相同的双亲 $E$ ，即 $K$ 和 $L$ 为兄弟**

- **树中一个结点的孩子个数称为该结点的度，树中结点的最大的度称为树的度。如结点 $B$ 的度为 $2$，结点 $D$ 的度为 $3$，树的度为 $3$；度大于 $0$ 的结点称为分支结点（又称非终端结点）；度为 $0$ 即没有子结点的结点，称为叶子结点（又称终端结点）。分支结点的分支数就是其度**

- **结点的深度、高度和层次。结点的层次从树根开始定义，根结点为第 $1$ 层，它的子结点为第 $2$ 层，以此类推。双亲在同一层的结点互为堂兄弟，结点 $G$ 与 $E,F,H,I,J$ 互为堂兄弟**

  > *结点的深度是从根结点开始自顶向下逐层累加的*
  >
  > *结点的高度是从叶结点开始自底向上逐层累加的*
  >
  > *树的高度（深度）是树中结点的最大层数*

- **有序树与无序树。树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则称为无序树。假设为有序树，若将子结点位置互换，则变成一棵不同的树**

- **路径与路径长度。树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数，由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩子之间不存在路径**

- **树的基本性质**

  > *树中的结点数等于所有结点的度之和加 $1$*
  >
  > 度为 $m$ 的树中第 $i$ 层上至多有 $m^{i-1}$ 个结点其中 $i\geq1$
  >
  > *高度为 $h$ 的 $m$ 叉树至多有 $(m^h-1)\over(m一1)$ 个结点*
  >
  > *具有 $n$ 个结点的 $m$ 叉树的最小高度为 $\lceil log_m[n(m-1)+1]\rceil$*

- **树的顺序存储结构**

  > *双亲表示法。用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置*

- **树的链式存储结构**

  > *孩子表示法。把每个结点的孩子结点排列起来存储成一个单链表。所以 $n$ 个结点就有 $n$ 个链表，如果是叶子结点，那这个结点的孩子单链表就是空的，然后 $n$ 个单链表的的头指针又存储在一个顺序表（数组）中*
  >
  > *孩子兄弟表示法。顾名思义就是要存储子结点与子结点的兄弟，具体来说，就是设置两个指针，分别指向该结点的第一个子结点和这个子结点的兄弟结点*

**森林是 $m\;(m\geq0)$ 棵互不相交的树的集合。森林的概念与树的概念十分相近，只要把树的根结点删去其子树就成了森林。反之，只要给 $m$ 棵树一个共同的结点，并把这 $m$ 棵树作为该结点的孩子，森林就变成了树**





### **二叉树**

**二叉树是有序树，特点是每个结点至多只有两个子结点即子树（二叉树中不存在度大于 2 的结点）并且二叉树的子树有左右之分，其次序不能任意频倒。二叉树由一个根结点和两个互不相交的被称为根的左子树和右子树组成，左子树和右子树又分别是一棵二叉树。二叉树是 $n\;(n\geq0)$ 个结点的有限集合，空二叉树 $n=0$**

**二叉树有五种基本形态**

- **空的，没有结点**
- **只有一个根结点**
- **根结点只有左子树**
- **根结点只有右子树**
- **根结点既有左子树又有右子树**

**二叉树与度为 $2$ 的有序树不同**

- **二叉树可以为空而度为 $2$ 的有序树至少有 $3$ 个结点**

- **度为 $2$ 的有序树的子结点的左右次序是相对于另一子结点而言的，若某个结点只有一个子结点，则这个子结点就无须区分左右次序，而二叉树的结点无论其子结点是否为 $2$ 均需事先定义左右次序，即二叉树的结点次序不是相对于另一结点而言，而是事先确定的**

**逻辑结构独特的二叉树**

* **满二叉树**

  > *一棵高度为 $h$，且含有 $2^h-1$ 个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为 $2$。可以对满二叉树按层序编号，约定编号从根结点（根结点编号为 $1$）起，自上而下，自左向右。这样，每个结点对应一个编号，对于编号为 $i$ 的结点，若有双亲，则其双亲为 $\lfloor {i\over2} \rfloor$，若有左子结点则为 $2i$， 若有右子结点则为 $2i+1$* 
  >
  > 
  >
  > <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%AA%E5%B1%8F2022-04-22%2016.07.09.png" alt="截屏2022-04-22 16.07.09" width="300px;" />

* **完全二叉树**

  > *高度为 $h$、$n$ 个结点的二叉树，当且仅当其每个结点都与高度为 $h$ 的满二又树中编号为 $1～n$ 的结点一一对应时，称为完全二叉树，若 $i\leq \lfloor \frac{n}{2}\rfloor$，则结点 $i$ 为分支结点，否则为叶子结点*
  >
  > 
  >
  > <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%AA%E5%B1%8F2022-04-22%2016.08.47.png" alt="截屏2022-04-22 16.08.47" width="300px;" />
  >
  > 
  >
  > *只可能有一个度为 $1$ 的结点，且该结点只有左孩子而无右孩子。若 $n$ 为奇数，则每个分支结点都有左孩子和右孩子；若 $n$ 为偶数，则编号最大的分支结点（编号为$n\over2$）只有左孩子，没有右孩子，其余分支结点左、右孩子都有*
  >
  > ***堆是顺序存储在一维数组中的完全二叉树，结点中的数据元素不大于根结点的称为大根（顶）堆，数据元素不小于根结点的称为小根（顶）堆*** 

* **线索二叉树**

  > *二叉树以双链表存储，将结点中空闲的指针域指向存储结构中的直接前驱或后继，构成一条额外的线索帮助二叉树遍历*

* **二叉排序树**

  > *左子树上所有结点的值均小于根结点的值；右子树上的所有结点的值均大于根结点的值；左子树和右子树又各是一棵二叉排序树*

* **平衡二叉树**

  > *树的任一结点的左子树和右子树的深度之差不超过 $1$*

* **哈夫曼树**

  > *树中结点赋给一个带有某种含义的权值。若根结点到全部结点之间的路径长度与结点的权的乘积的和最小，则为哈夫曼树*

**二叉树的性质**

* **非空二叉树上叶子结点数等于度为 $2$ 的结点数加 $1$，即 $n_0=n_2+1$**
* **非空二叉树上第 $K$ 层上至多有 $2^k−1$ 个结点 $(k≥1)$**
* **高度为 $h$ 的二叉树至多有 $2^h-1$ 个结点 $(h≥1)$**
* **具有 $n$ 个 $(n>0)$ 结点的完全二叉树的高度为 $\lceil log_2(n+1)\rceil$ 或 $\lfloor log_2n\rfloor+1$**



#### **二叉树的存储结构**

**有一棵二叉树，高为 $4$，结点数为 $6$ 各数据元素分别为 $123456$**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220422225725597.png" alt="image-20220422225725597" width="250px;" />



* **顺序存储**
  
    > *二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点，在顺序表中的存储顺序就是结点在完全二叉树中的编号顺序*
    >
    > 
    >
    > <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220422173412233.png" alt="image-20220422173412233" width="500px;" />
    >
    > 
    >
    > *二叉树的顺序存储已知一个结点的编号就能快速的找到其双亲和孩子结点，但该存储结构不适合结点的删除和插入，此外存储非完全二叉树时，顺序表中会出现很多空闲位置*
* **链式存储**
  
    > *二叉树每个结点最多两个孩子，所以设计二叉树的结点结构体时定义一个结点数据域与两个子结点指针域，存储数据与描述逻辑*
    >
    > 
    >
    > <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220422173610903.png" alt="image-20220422173610903" width="550px;" />
    >
    > 
    >
    > *定义二叉树数据结构*
    >
    > ```c
    > typedef struct BiTNode{
    >   int data;
    >   struct BiTNode *lchild, *rchild;
    > }BiTNode, *BiTree;
    > ```
    >
    > 
    >
    > <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220422173536164.png" alt="image-20220422173536164" width="250px;" />



#### **二叉树的遍历**

**二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。由二叉树的递归定义可知，遍历一棵二叉树要决定对根结点 $N$、左子树 $L$ 和右子树 $R$ 的访问顺序，常见的遍历次序有先序 $(NLR)$、中序 $(LNR)$ 和后序 $(LRN)$ 算法（其中“序”是指访问根结点相对于左子结点与右子结点的顺序，按照从上往下从左往右的顺序深度优先遍历）以及层次遍历算法等**

**二叉链表存储二叉树为例**

* **先序遍历**
  
  > *如果二叉树不为空，则先找到树的根结点与左右结点组成的一颗二叉树，然后访问树的根结点，接着访问左结点，再访问右结点，且访问每个结点时都需要先执行自身为根结点的「根左右」的逻辑，再考虑执行从祖先继承的自身为左右结点的「根左右」逻辑*
  >
  > *递归方法*
  >
  > ```c
  > void PreOrder(BiTree T){
  > if(T!=NULL){
  >  visit(T);  // 访问根结点
  >  PreOrder(T->lchild);  // 找到全部的左结点
  >  PreOrder(T->rchild);  // 找到全部的右结点
  > }
  > }
  > 
  > void visit(BiTree T){
  > printf("%c", T->data);
  > }
  > ```
  >
  > *非递归方法*
  >
  > ```c
  > void PreOrderTraverse(BiTree T){
  > initStack(S);  // 开辟存储指针的栈空间
  > BiTree P = T;
  > while(P || !isEmpty(S)){
  >  while(P){
  >    visit(P);  // 根结点到左结点依次压栈
  >    Push(S, P);
  >    P = P->lchild;
  >  }
  >  if(!isEmpty(S)){
  >    P = Pop(S);  // 最后一层的右叶子结点依次出栈
  >    P = P->rchild;
  >  }
  > }
  > }
  > ```
  >
  > *遍历得到的结点序列为 $124635$*
  
* **中序遍历**
  
  > *如果二叉树不为空，则先找到树的根结点与左右结点组成的一颗二叉树，先访问树的左结点，接着访问根结点，再访问右结点，且访问每个结点时都需要先执行自身为根结点的「左根右」的逻辑，再考虑执行从祖先继承的自身为左右结点的「左根右」逻辑*
  >
  > *递归方法*
  >
  > ```c
  > void InOrder(BiTree T){
  > if(T!=NULL){
  >  InOrder(T->lchild);  // 找到全部的左结点
  >  visit(T);  // 访问根结点
  >  InOrder(T->rchild);  // 找到全部的右结点
  > }
  > }
  > ```
  >
  > *非递归方法*
  >
  > ```c
  > void InOrderTraverse(BiTree T){
  > initStack(S);
  > BiTree P = T;
  > while(P || !isEmpty(S)){
  >  while(P){
  >    Push(S, P);
  >    P = P->lchild;
  >  }
  >  if(!isEmpty(S)){
  >    P = Pop(S);
  >    visit(P);
  >    P = P->rchild;
  >  }
  > }
  > }
  > ```
  >
  > *遍历得到的结点序列为 $264135$，直观来看，就是将二叉树的结点投影到一条水平的坐标上*
  
* **后序遍历**
  
  > *如果二叉树不为空，则先找到树的根结点与左右结点组成的一颗二叉树，先访问左结点，接着访问右结点，再访问树的根结点，且访问每个结点时都需要先执行自身为根结点的「左右根」的逻辑，再考虑执行从祖先继承的自身为左右结点的「左右根」逻辑*
  >
  > *递归方法*
  >
  > ```c
  > void PostOrder(BiTree T){
  > if(T!=NULL){
  >  PostOrder(T->lchild);  // 找到全部的左结点
  >  PostOrder(T->rchild);  // 找到全部的右结点
  >  visit(T);  // 访问根结点
  > }
  > }
  > ```
  >
  > *非递归方法*
  >
  > ```c
  > void PostTraverse(BiTree T){
  > initStack(S);
  > BiTree P = T, R = NULL;
  > while(P || !isEmpty(S)){
  >  // 从左子树的左叶子结点入栈
  >  if(P){
  >    Push(S, P);
  >    P = P->lchild;
  >  }
  >  else{
  >    GetTop(S, P);  // 取顶栈
  >    if(P->rchild && P->rchild != R){
  >      P = P->rchild;
  >    }
  >    else{
  >      P = Pop(S);
  >    	 visit(P);
  >      R = P;
  >      P = NULL;
  >    }
  >  }
  > }
  > }
  > ```
  >
  > *遍历得到的结点序列为 $642531$*
  

**递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是 $O(n)$。在递归遍历中，递归工作栈的栈深怡好为树的深度，所以在最坏情况下，二叉树是有 $n$ 个结点且深度为 $n$ 的单支树，遍历算法的空间复杂度为 $O(n)$。实际上，访问一个结点 $p$ 时，栈中结点恰好是 $p$ 结点的所有祖先，从栈底到栈顶结点再加上 $p$ 结点，刚好构成从根结点到 $p$ 结点的一条路径。在很多算法设计中都可以利用这一思路来求解，如求根到某结点的路径、求两个结点的最近公共祖先等**

* **层次遍历**

  > *如果二叉树不为空，则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问*
  >
  > *进行层次遍历需要使用队列，先将二叉树根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队，若它有右子树，则将右子树根结点入队，然后出队，访问出队结点⋯⋯如此反复，直至队列为空*
  >
  > ```c
  > void LevelOrder(BiTree T){
  >   initQueue(Q);
  >   BiTree P;
  >   enQueue(Q, P);  // 根结点入队
  >   while(!isEmpty(Q)){
  >     deQueue(Q, P);  // 队头结点出队
  >     visit(P);  // 访问出队结点
  >     if(P->lchild != NULL)
  >       enQueue(Q, P->lchild);  // 左子树根结点入队
  >     if(P->rchild != NULL)
  > 			enQueue(Q, P->rchild);  // 右子树根结点入队
  >   }
  > }
  > ```
  >
  > *遍历得到的结点序列为 $123456$*



##### **线索二叉树**

**遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（除第一个和最后一个结点外）都有一个直接前驱和直接后继。传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。**

**例如 $n$ 个结点的二叉树，每个结点都有指向左右孩子的结点指针，所以一共有 $2n$ 个指针，而 $n$ 个结点的二叉**
**树一共有 $n-1$ 条分支，也即存在 $2n-(n-1)=n+1$ 个空指针，可以利用空余的指针实现指向结点前驱与后继的指针即线索，具有线索的二叉树就称为线索二叉树**

- *规定无左子树，令 $lchild$ 指向其前驱结点，无右子树，令 $rchild$ 指向其后继结点，还需增加两个标志域标识指针域是指向左（右）孩子还是指向前驱（后继）*



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220424201449069.png" alt="image-20220424201449069" width="500px;" />


$$
ltag=\begin{cases}
0,\quad lchild\;域指示结点的左孩子\\
1,\quad lchild\;域指示结点的前驱
\end{cases}\\
rtag=\begin{cases}
0,\quad rchild\;域指示结点的右孩子\\
1,\quad rchild\;域指示结点的后驱
\end{cases}
$$

```c
typedef struct ThreadNode{
	int data;
	struct ThreadNode *lchild, *rchild;
  int ltag, rtag;
}ThreadNode, *ThreadTree;
```



#### **二叉排序树**

**二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有以下性质的二叉树**

- **若左子树不空，则左子树上所有结点的值均小于它的根结点的值**
- **若右子树不空，则右子树上所有结点的值均大于它的根结点的值**
- **它的左右子树也是一棵二叉排序树**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220425104322764.png" alt="image-20220425104322764" width="150px;" />



**由于二叉排序树的特点（左子树<根结点<右子树），所以每次查找一个关键字，需要先和根结点进行较，如果这个关键字小于根结点的值，则再到这个根结点的左子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。如果这个关键字大于根结点的值，则再到这个根结点的右子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，如果是空指针，表示查找失败**

- **查找关键字**

  > *递归方法*
  >
  > ```c
  > BSTNode *BST_Search（BiTree *t, int key)
  > {
  >   if(t==NULL) return NULL;
  >   else
  >   {
  >     if(t->key==key) return t;
  >     else if(key<t->key) return BST_Search(t->lchild, key);
  >     sles return BST_Search(t->rchild, key);
  >   }
  > }
  > ```
  >
  > **非递归方法**
  >
  > ```c
  > BSTNode *BST_Search（BiTree *t, int key)
  > {
  >   BiTree *p = t;
  >   while(p!=NULL && key!=p->data)
  >   {
  >     if(key<p->data) p=p->lchild;
  >     else p=p->rchild;
  >   }
  >   return p;
  > }
  > ```

- **插入关键字**

  > *二叉排序树为空树则直接插入新结点，树非空则检查是否存在关键字重复的结点，存在则插入失败，不存在则检查根结点的值和待插入关键字值的大小关系递归插入左右子树*
  >
  > ```cpp
  > int BST_Insert(BiTree &t, int k)
  > {
  >   if(t==NULL)
  >   {
  >     t=(BiTree)malloc(sizeof(BSTNode));
  >     t->key=k;
  >     t->lchild=t->rchild=NULL;
  >     return 1;
  >   }
  >   else if(k==t->key) return 0;
  >   else if(k<t->key) return BST_Insert(t->lchild, k);
  >   else return BST_Insert(t->rchild, k);
  > }
  > ```

- **构造二叉排序树**

  > ```cpp
  > void Creat_BST(BiTree &t, int str[], int n)
  > {
  >   t=NULL;
  >   int i=0;
  >   while(i<n)
  >   {
  >     BST_Insert(t, str[i]);
  >     i++;
  >   }
  > }
  > ```

- **删除关键字**

  > *删除的是叶子结点则直接删去该结点即可，删除的是仅有左子树或右子树的结点则直接子承父业，删除的是有左右子树的结点则找到待删除结点的直接前驱或直接后继结点，用该结点来替代待删除结点*

**从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找相近，但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键宇其插入顺序不同可能生成不同的二叉排序树，在最坏情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树，此时二叉排序树的性能显著变坏，树的高度也增加为元素个数 $n$，查找的时间复杂度是 $O(n)$**



##### **平衡二叉树**

**平衡二叉树是特殊的二叉排序树，要求左右子树的高度之差绝对值不超过 $1$，且左右子树也是一棵平衡二叉树，含有 $n$ 个结点平衡二叉树的最大深度为 $O(log_2n)$**

* **平衡因子**

  > *结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是 $−1$、$0$ 或 $1$*

* **平衡调整**

  > *平衡二叉树的建立过程和二叉排序树的建立过程是相似的，都是从一棵空树开始陆续插入结点。不同的地方在于对于平衡二叉树的建立过程中，需要进行平衡调整，防止插入结点破坏树的平衡性*
  >
  > *$LL$ 平衡旋转（左孩子的左子树上插入结点导致）*
  > *最小不平衡子树根结点的平衡因子为 2>0，它的左孩子结点平衡因子为1>0，两个都大于0，所以直接右旋就可以调整，即该结点的根结点变成该结点的右子树的根结点，该结点的原右子结点变成此时右子结点的左子结点，简称正则右旋*
  >
  > *$RR$ 平衡旋转（右孩子的右子树上插入结点导致）*
  > *最小不平衡子树根结点的平衡因子为 $-2<0$，它的右孩子结点平衡因子为 $-1<0$，两个都小于 $0$，所以直接左旋就可以调整，即该结点的根结点变成该结点的左子树的根结点，该结点的原左子结点变成此时左子结点的右子结点，简称负则左旋*
  >
  > *$LR$ 平衡调整（左孩子的右子树上插入结点导致）与 $RL$ 平衡调整（右孩子的左子树上插入结点导致），先局部转换为适用 $LL$ 或 $RR$ 情形，再进行相应调整即可*



#### **哈夫曼树**

**树中结点常常被赋子一个表示某种意义的数值，称为该结点的权。从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积，称为该结点的带权路径长度。树中所有叶结点的带权路径长度之和称为该树的带权路径长度为 $WPL=\sum^{n}_{i=1}w_il_i$，$w_i$ 是第 $i$ 个叶结点所带的权值，$l_i$ 是该叶结点到根结点的路径长度，在含有 $n$ 个带权叶结点的二叉树中，其中带权路径长度 $(WPL)$ 最小的二叉树称为哈夫曼树，也称最优二叉树**



##### **哈夫曼树的构造**

* **第一，我们先得到全部数据元素的权重集合（权值可用每个数据元素的频率），其中的结点分别作为仅含一个结点的二叉树，构成森林 $f$**
* **第二，构造一个新结点，并从 $f$ 中选取根结点权值最小的两棵树作为新结点的左（最小）、右（次小）子树，并且将新结点的权值设为左、右子树的根结点的权值之和**
* **第三，从 $f$ 中删除刚才选出的两棵树，同时将新得到的树加入 $f$ 中**
* **第四，重复第一与第二直至 $f$ 中只剩一棵树为止**

**通过哈夫曼树可以实现哈夫曼编码，是不等长的可变长度编码，可以压缩数据元素的存储空间大小**

- **令左子树为边值 $0$，右子树边值为 $1$，从哈夫曼树的根结点顺着边到目标子结点的边的序列值就是哈夫曼编码值**



##### **哈夫曼树的实例**

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct
{
	int data; // data域存储权值
	int parent, lchild, rchild; // 双亲与孩子
} HTNode, *HuffmanTree;

void InitHuffmanTree(HuffmanTree H, int weight, int parent, int lchild, int rchild)
{
	H->lchild = lchild;
	H->rchild = rchild;
	H->parent = parent;
	H->data = weight;
}

void CreateHuffmanTree(HuffmanTree &HT, int n, int *W)
{
	// 叶子结点的初始化，相当于n棵树，每颗树只有一个结点，那么最后构造过程总的结点个数为：2*n-1
	// n-1+n = 2*n-1

	HT = (HuffmanTree)malloc((2 * n - 1) * sizeof(HTNode)); // n个叶子结点的哈夫曼树结点是2n-1;
	for (int i = 0; i < n; i++)
	{
		InitHuffmanTree(HT + i, W[i], -1, -1, -1); // 初始化-1
	}
	// 开始寻找最小的两个叶子结点，构造哈夫曼树
	for (int i = n; i < 2 * n - 1; i++)
	{								   // 我们构造n-1个度为2的结点
		int min1 = 65522, min2 = min1; // 这里的两个数分别代表第一小，第二小
		int x1 = -1, x2 = -1;		   // 用来记录下标
		for (int j = 0; j < i; j++)
		{
			if ((HT + j)->parent == -1) //表示叶子结点没有父母
			{
				if ((HT + j)->data < min1)
				{
					min2 = min1;
					min1 = (HT + j)->data;
					x2 = x1;
					x1 = j;
				}
				else if ((HT + j)->data < min2)
				{
					min2 = (HT + j)->data;
					x2 = j;
				}
			}
		}
		// 合并两个叶子，让他们有同一个双亲
		(HT + x1)->parent = i;
		(HT + x2)->parent = i;
		// 然后我们让HT[i]指向这两个孩子，为了后来的逆序哈夫曼编码

		InitHuffmanTree(HT + i, min2 + min1, -1, x1, x2); // 父结点构造
	}
}

void HuffmanTreeCode(HuffmanTree HT, char *str, int n, int path, int &e)
{
	int i = 0, j = 0, m = 0;
	int child = path; // 假设我们现在在叶子结点为child索引的地方，如1

	int parent = (HT + child)->parent; // 获取第一个叶子结点的父节点 的值
	// printf("leafe node is:%d \n",(HT+child)->data);

	// 开始逆序寻找根节点，及生成编码
	for (i = n - 1; parent != -1; i--) // 当前结点不是根结点 ,逆序
		if ((HT + parent)->lchild == child)
		{ // 他的双亲指向的左孩子是不是我们当前遍历的这个叶子
			str[j++] = '0';
			child = parent; // 此时parent！=-1 ，表示还有父节点
			parent = (HT + child)->parent;
		}
		else
		{
			str[j++] = '1'; // 实现编码
			child = parent;
			parent = (HT + child)->parent;
		}
	e = j; // 表示一个叶子结点的编码结束
}

int main()
{
	int i, n;
	int *w, e;

	HuffmanTree HT;
	printf("Node Number:");
	scanf("%d", &n);					// 权值个数
	w = (int *)malloc(n * sizeof(int)); // 权值数组
	printf("Input weights:");
	for (i = 0; i < n; i++) // 录入权值
		scanf("%d", &w[i]);
	CreateHuffmanTree(HT, n, w);
	printf("the first node is:%d\n",HT->data);
	printf("create sussessfully\n");

	char str[n];
	for (int k = 0; k < n; k++)
	{
		HuffmanTreeCode(HT, str, n, k, e);
		for (int j = e - 1; j >= 0; j--)
			printf("%c", str[j]);
		printf("\n");
	}
	free(HT);
	return 0;
}
```



#### **二叉树的转化**

- **将二叉树从上到下分层，每遇到左孩子则为一层**

- **若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点等，都作为结点的孩子，将结点与这些右孩子结点用线连接起来**
- **删除原二叉树中所有结点与其右孩子结点的连线**



<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220424212824443.png" alt="image-20220424212824443" width="450px;" />



**若反复断开二叉树根结点的右孩子的右子树指针，直到不存在根结点有右孩子的二叉树时就转化成了森林，相似的也可以将一般树甚至森林转化成二叉树**







## **图**

**图是描述于一组对象的结构，其中某些对象对在某种意义上是相关的。这些对象的数学抽象称为顶点的（也称结点或点），并且每个相关的顶点对都称为边（也称为链接或线）**



### **图的基本概念**

- **图的定义**

  **$G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,E)$**

  1. **$V(G)$ 表示图 $G$ 中顶点的有限非空集，若 $V=\{v_1,v_2,\cdots,v_n\}$ 则用 $|V|$ 表示图 $G$ 中顶点的个数，也称为图 $G$ 的阶**
  2. **$E(G)$ 表示图 $G$ 中顶点之间边（关系）的集合，若 $E=\{(u，v)\mid u \in V, v \in V\}$ 则用 $|E|$ 表示图 $G$ 中边的条数**

  > *树是图的子集，是一种特殊的图，定义是 $n,(n≥0)$ 个结点的有限集合，$n=0$ 时称为空树，而任意一棵非空树中应满足*
  >
  > 1. *有且仅有一个特定的称为根的结点*
  > 2. *当 $n>1$ 时，其余结点可分为 $m(m>0)$ 个互不相交的有限集合 $T_1,T_2,\cdots,T_m$，其中每一个集合本身又是一棵树，称为根结点的子树*	

* **图的分类**

    1. **无向图**

       **$E$ 无向边的有限集合，边是顶点的无序对，记为 $(v,w)$ 且 $(v,w)=(w,v)$，称 $w,v$ 互为邻接点**

    2. **有向图**

       **$E$ 是有向边（弧）的有限集合，弧是顶点的有序对，记为 $<v,w>$，$v$ 是弧尾，$w$ 是弧头，称 $v$ 邻接到 $w$ 或 $w$ 邻接自 $v$**

    3. **简单图**

       **不存在顶点到自身的边，同一条边不重复出现**

    4. **多重图**

       **与简单图相对，某两个结点之间的边数多于一条，且允许顶点通过通过同一个边和自己关联**

    5. **完全图**
       - **无向完全图，任意两个顶点之间都存在边**
       - **有向完全图，任意两个顶点之间都存在方向相反的两条弧**

    6. **子图**

       **设有两个图 $G=(V,E)$ 和 $G^\prime=(V^\prime,E^\prime)$ 若 $V^\prime$ 是 $V$ 的子集，且 $E^\prime$ 是 $E$ 的子集，则称 $G^\prime$ 是 $G$ 的子图。若有满足 $V(G^\prime)=V(G)$ 的子图 $G^\prime$，则称其为 $G$ 的生成子图**

       > *并非 $V$ 和 $E$ 的任何子集都能构成 $G$ 的子图，因为这样的子集可能不是图，即 $E$ 的子集中的某些边关联的顶点可能不在这个 $V$ 的子集中*

    7. **连通图**

       **在无向图中，若从顶点 $v$ 到顶点 $w$ 有路径存在，则称 $v$ 和 $w$ 是连通的。若图 $G$ 中任意两个顶点都是连通的，则称图 $G$ 为连通图，如果一个图有 $n$ 个顶点，并且有小于 $n-1$ 条边称为非连通图**

       - **连通分量**

         **无向图中的极大连通子图，即选取一个顶点，以这个顶点作为一个子图，然后逐个添加与这个子图相连的顶点和边直到所有相连的顶点都加入该子图**

       - **强连通图**

         **在有向图中，若顶点 $v$ 到顶点 $w$ 和顶点 $w$ 到顶点 $v$ 都有路径则这两个顶点称为强连通。若 $G$ 图中任一对顶点都是强连通的，则称图 $G$ 为强连通图**

    8. **连通图的生成树**

       **包含图中全部 $n$ 个顶点，但是只有 $n-1$ 条边的极小连通子图，对于该生成树而言，去掉一条边则变成非连通图，加上一条边就会形成回路**

    9. **顶点的度**

       **以顶点为一个端点的边数目**

       - **无向图中顶点 $v$ 的度是指依附于该顶点的边的条数，记为 $TD(v)$**
       - **有向图中顶点 $v$ 的度分为出度 $ID$ 以顶点 $v$ 为起点的有向边的数目，入度 $OD$ 以顶点 $v$ 为终点的有向边的数目** 

    10. **边的权和网**

        **图中每条边都可以赋予一定意义的数值，这个数值叫做这条边的权，有权值得图称为带权图，也叫做网**

    11. **路径、路径长度和回路**

        **顶点 $v_p$ 到 $v_q$ 之间的路径是指顶点序列 $v_p,v_{i_1},v_{i_2},\cdots,v_{i_m},v_q$，路径上边的数目就是路径长度，第一个和最后一个顶点相同的路径称为回路或者环**

        > *若一个图有 $n$ 个顶点，并且有大于 $n-1$ 条边则此图必有环*

        - **简单路径**

          **顶点不重复出现的路径**

        - **简单回路**

          **除了第一个和最后一个顶点其余顶点不重复出现的回路**

    12. **距离**

        **从顶点 $u$ 到 $v$ 的最短路径长度为其距离。不存在路径，则记距离为无穷 $\infin$**





### **图的存储结构**

* **顺序存储**

    **邻接矩阵，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息即各顶点之间的邻接关系，存储顶点之间邻接关系的二维数组称为邻接矩阵**

    > *结点数为 $n$ 的图 $G=(V,E)$ 的的邻接矩阵 $A$ 是 $n\times n$ 的。将 $G$ 的顶点编号为 $v_1,v_2,\cdots,v_n$，若$(v_i,v_j)\in
    > E$，则 $A[i][j]=1$，否则 $A[i][j]=0$。若为带权图，$v_i$ 与 $v_j$ 有边连接则邻接矩阵中存放边的权值 $A[i][j]=w_{ij}$ 否则 $A[i][j]=\infin$*
    >
    > <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220622000130159.png" alt="image-20220622000130159" style="zoom:33%;" />
    >
    > <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220622000204893.png" alt="image-20220622000204893" style="zoom: 33%;" />

* **顺序存储与链式存储**

    **邻接表，是指对图 $G$ 中的每个顶点以 $v_i$ 建立一个单链表，第 $i$ 个单链表中的结点表示依附于顶点 $v_i$ 的边（对于有向图则是以顶点 $v_i$ 为尾的弧），这个单链表就称为顶点 $v_i$ 的边表（对于有向图则称为出边表）。边表的头指针与顶点的数据信息采用顺序存储，称为顶点表，所以在邻接表中存在两种结点，顶点表结点与边表结点**

    <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220622000029665.png" alt="image-20220622000029665" style="zoom: 33%;" />

    <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220622000253895.png" alt="image-20220622000253895" style="zoom:33%;" />

- **链式存储**

  1. **十字链表用于存储有向图，对应于有向图中的每条弧有一个弧结点，其中有 $5$ 个域：尾域（tailvex）和头域（headvex）分别指示弧尾和弧头这两个顶点在图中的位置：两个链域 （hlink 与 tlink）分别指向弧头相同的下一条弧与弧尾相同的下一条弧；信息域（info）指向该弧的相关信息。弧头相同的弧就在同一个链表上，弧尾相同的弧也在同个链表上。对应于每个顶点也有一个结点，顶点结点中有 $3$ 个域，数据域（data）存放顶点相关的数据信息，如顶点名称；两个链域（firstin 与 firstout）分别指向以该顶点为弧头与弧尾的第一个弧结点**

     <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220621235846530.png" alt="image-20220621235846530" style="zoom: 33%;" />

  2. **邻接多重表用于存储无向图，与十字链表类似，每条边用一个结点表示，边结点包含六个域，其中标志域（mark）表示边是否被搜索过，两个位置域（ivex 与 jvex）分别表示该边依附的两个顶点在图中的位置，两个链域（ilink 与 jlink）分别指向下一条依附于相应顶点的边地址，信息域（info）指向和边相关的各种信息。对应于每个顶点也有一个结点，顶点结点中有 $2$ 个域，数据域（data）存放顶点相关的数据信息；链域（firstedge）指向第一个依附该顶点的边**

     <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20220622001739968.png" alt="image-20220622001739968" style="zoom: 33%;" />

- **基本操作**

  **例如，判断、插入、删除和数边等操作都独立于图的存储结构，对于不同的存储方式，操作算法的具体实现的性能不同。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高**





### **图的遍历**

<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE.png" alt="20200829171135149" width="200px;" />

* **深度优先遍历**
  
    **即深度优先搜索（DFS，Depth-First-Search）类似于树的先序、中序和后序遍历算法，故也适用于树，首先访问图中某一起始顶点 $v$，然后由 $v$ 出发，访问与 $v$ 邻接且末被访问的任一顶点 $w_1$，再访问与 $w_1$ 邻接且未被访问的任一顶点 $w_2,\cdots$ 重复上述过程，一条路径一直走到底。当不能再继续向下访问时，进行回溯，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止，简要来说就是对每一个可能的分支路径深入到不能再深入为止，如果遇到死路就往回退，回退过程中如果遇到没探索过的支路，就进入该支路继续深入，每个节点只访问一次**
    
    1. **举例**
    
       > ***算法逻辑***
       >
       > 1. *首先，创建一个空堆栈 $stack$（用来存放结点）和一个空列表 $visit$（用来存放已访问的结点）*
       > 2. *其次，从 $v_A$ 开始， $v_A$ 压入堆栈，此时 $visit=\{\emptyset\},queue=\{v_A\}$*
       > 3. *当 $v_A$ 推出堆栈时 $visit=\{v_A\}$，$v_A$ 的邻接结点 $v_B,v_C,v_D$ 压入堆栈，此时 $stack=\{v_B,v_C,v_D\}$*
       > 4. *接着堆栈尾 $v_D$ 推出堆栈，此时 $visit=\{v_A,v_D\}$，$v_D$ 的邻接结点中 $v_A,v_C,v_G$ 中未压入堆栈的  $v_G$ 压入堆栈，此时 $stack=\{v_B,v_C,v_G\}$*
       > 5. *然后堆栈尾 $v_G$ 推出堆栈，此时 $visit=\{v_A,v_D,v_G\}$，$v_G$ 的邻接结点中 $v_C,v_D$ 已经全部压入过堆栈的故不再压栈 ，此时 $stack=\{v_B,v_C\}$*
       > 6. *再然后堆栈尾 $v_C$ 推出堆栈，此时 $visit=\{v_A,v_D,v_G,v_C\}$，$v_C$ 的邻接结点中 $v_A,v_D,v_F,v_G$ 中未压入堆栈的  $v_F$ 压入堆栈，此时 $stack=\{v_B,v_F\}$*
       > 7. *再然后堆栈尾 $v_F$ 推出堆栈，此时 $visit=\{v_A,v_D,v_G,v_C,v_F\}$，$v_F$ 的邻接结点中 $v_B,v_C$ 已经全部压入过堆栈的故不再压栈，此时 $stack=\{v_B\}$*
       > 8. 再然后堆栈尾 $v_B$ 推出堆栈，此时 $visit=\{v_A,v_D,v_G,v_C,v_F,v_B\}$，$v_B$ 的邻接结点中 $v_A,v_E,v_F$ 中未压入堆栈的  $v_E$ 压入堆栈，此时 $stack=\{v_E\}$
       > 9. *最后 $v_E$ 结点压出堆栈直到 $stack=\{\emptyset\},visit=\{v_A,v_D,v_G,v_C,v_F,v_B,v_E\}$*
       >
       > ***算法实现***
       >
       > ```python
       > # 用字典结构表示图的邻接表
       > graph_nt = {
       >     'A' : ['B','C','D'],
       >     'B' : ['A','E','F'],
       >     'C' : ['A','D','F','G'],
       >     'D' : ['A','C','G'],
       >     'E' : ['B'],
       >     'F' : ['B','C'],
       >     'G' : ['C','D']
       > }
       > 
       > def DFS(start, graph):
       >     stack = []
       >     visit = []
       >     stack.append(start)
       >     while stack:
       >         node = stack.pop()
       >         visit.append(node)
       >         nodes = graph[node]
       >         for i in nodes:
       >             if i not in visit:
       >                 stack.append(i)
       >                 visit.append(i)
       >         print(node,end='\t')
       > 
       > DFS(start='A', graph=graph_nt)
       > ```
    
    2. **空间复杂度**
    
       **由于 DFS 是一个递归算法，需要一个工作栈来辅助工作，最多需要图中所有顶点进栈，所以空间复杂度为 $O(|V|)$**
    
    3. **时间复杂度**
    
       **邻接矩阵，查找每个顶点的邻接点时间复杂度为 $O(|V|)$，对每个顶点都进行查找，所以总的时间复杂度为 $O(|V|^2)$**
    
       **邻接表，遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为 $O(|E|)$，访问顶点时间为 $O(|V|)$，所以总的时间复杂度为 $O(|V|+|E|)$**
    
* **广度优先遍历**
  
    **即广度优先搜索（BFS，Breadth-First-Search）似于树的层次遍历算法，故也适用于树，其过程是以 $v$ 为起始点，由近至远依次访问和 $v$ 有路径相通且路径长度为 $1,2,\cdots$ 的顶点，广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，不是递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点**
    
    1. **举例**
    
       > ***算法逻辑***
       >
       > 1. *首先，创建一个空队列 $queue$（用来存放结点）和一个空列表 $visit$（用来存放已访问的结点）*
       > 2. *其次，从 $v_A$ 开始， $v_A$ 进入队列，此时 $visit=\{\emptyset\},queue=\{v_A\}$*
       > 3. *当 $v_A$ 出队列时 $visit=\{v_A\}$，$v_A$ 的邻接结点 $v_B,v_C,v_D$ 进入队列，此时 $queue=\{v_B,v_C,v_D\}$*
       > 4. *接着 $v_B$ 出队列，此时 $visit=\{v_A,v_B\}$，$v_B$ 的邻接结点中 $v_A,v_E,v_F$ 中未进入队列的  $v_E,v_F$ 进入队列，此时 $queue=\{v_C,v_D,v_E,v_F\}$*
       > 5. *然后 $v_C$ 出队列，此时 $visit=\{v_A,v_B,v_C\}$，$v_C$ 的邻接结点中 $v_A,v_D,v_F,v_G$ 中未进入队列的  $v_G$ 进入队列，此时 $queue=\{v_D,v_E,v_F,v_G\}$*
       > 6. *再然后 $v_D$ 出队列，此时 $visit=\{v_A,v_B,v_C,v_D\}$，$v_D$ 的邻接结点中 $v_A,v_C,v_G$ 已经全部进入过队列的故不再入队，此时 $queue=\{v_E,v_F,v_G\}$*
       > 7. *最后 $v_E,v_F,v_G$ 结点与 $v_D$ 情况类似，一直出队列直到 $queue=\{\emptyset\},visit=\{v_A,v_B,v_C,v_D,v_E,v_F,v_G\}$*
       >
       > ***算法实现***
       >
       > ```python
       > graph_nt = {
       >     'A' : ['B','C','D'],
       >     'B' : ['A','E','F'],
       >     'C' : ['A','D','F','G'],
       >     'D' : ['A','C','G'],
       >     'E' : ['B'],
       >     'F' : ['B','C'],
       >     'G' : ['C','D']
       > }
       > 
       > def BFS(start, graph):
       >     queue = []
       >     visit = []
       >     queue.append(start)
       >     while queue:
       >         node = queue.pop(0)
       >         visit.append(node)
       >         nodes = graph[node]
       >         for i in nodes:
       >             if i not in visit:
       >                 queue.append(i)
       >                 visit.append(i)
       >         print(node, end='\t')
       >         
       > BFS(start='A', graph=graph_nt)
       > ```
    
    2. **空间复杂度**
    
       **由于 BFS 需要借助一个队列，$n$ 个顶点均需要入队一次，所以最坏情况下 $n$ 个顶点在队列，那么则需要 $O(|V|)$ 的空间复杂度** 
    
    3. **时间复杂度**
    
       **邻接矩阵，每个顶点入队一次，时间复杂度为 $O(|V|)$，对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为 $O(|V|)$，所以总的时间复杂度为 $O(|V|^2)$**
    
       **邻接表，每个顶点入队一次，时间复杂度为 $O(|V|)$，对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为 $O(|E|)$，所以总的时间复杂度为 $O(|V|+|E|)$**





### **图的应用**

* **最小生成树（MST）一个连通图的生成树包含图的所有顶点，并且只包含尽可能少的边，如果带权图则选择所有边之和权值最小的生成树**
  
    1. **普利姆（Prlm）**
    
       > 1. *从图中找第一个起始顶点 $v_0$，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条距离最近（权值最小）的边。然后把这条边的另一个顶点 $v_1$ 和这条边加入到生成树中*
       > 2. 反复执行直到所有所有顶点都加入到生成树中
       >
       > <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%AA%E5%B1%8F2022-06-22%2012.11.53.png" alt="截屏2022-06-22 12.11.53" style="zoom: 33%;" />
       >
       > *图 $a$ 的最小生成树普利姆算法构建过程即 $b\rightarrow f$，包含双重循环，外层循环次数为 $\mid V\mid-1$，内层并列的循环次数都是 $\mid V\mid$，故普利姆算法时间复杂度为 $O(\mid V\mid^2)$，且时间复杂度只和结点数 $\mid V\mid$ 有关，适合稠密图*
    
    2. **克鲁斯卡尔（Kruskal）**
    
       > *将图中边按照权值从小到大排列存放在堆中，然后从最小的边开始扫描，每次选择最小边的时间复杂度是 $O(log\mid E\mid)$，设置一个边的集合来记录，如果该边并入不构成回路的话，则将该边并入当前生成树，直到所有的边都检测完为止*
       >
       > <img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%88%AA%E5%B1%8F2022-06-22%2012.24.45.png" alt="截屏2022-06-22 12.24.45" style="zoom:33%;" />
       >
       > *图 $a$ 的最小生成树克鲁斯卡尔算法构建过程即 $b\rightarrow f$，操作分为对边的权值排序部分和一个单重循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上，时间复杂度是 $O(\mid E\mid log\mid E\mid)$。排序和图中边的数量有关系，所以适合稀疏图*









## **排序算法**

 **排序算法是将原本无序的序列重新排列成有序的序列的算法**

* **排序算法大致分为 $5$ 类，交换类、插入类、选择类、归并类和桶相关类**

<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-5893797.png" alt="排序算法" width="500px;" />

- **排序算法执行过程中，在可预见使用不同的排序算法去排序不同的数据结构的序列，移动元素所需的时间复杂度与空间复杂度也是不同的，因此只分析排序算法的时间复杂度与空间复杂度。另外如果，待排序表中有两个元素 $R_i、R_j$，其对应的关键字 $key_i=key_j$，且在排序前 $R_i$ 在 $R_j$ 前面，如果使用某一排序算法排序后，$R_i$ 仍然在 $R_j$ 的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的，不稳定将增加额外的复杂度**



### **交换类**

#### **冒泡排序**

<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20200916003718570.gif" alt="20200916003718570" style="zoom:50%;" />

1. **算法逻辑**

   > *假设待排序表长为 $n$，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即$A[i-1]>A[i]$），则交换它们，直到序列比较完成，称为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，这样最多做 $n-1$ 趟冒泡就能把所有元素排好序*

2. **算法实现**

   ```python
   def bubble_sort(List):
       # 1. 原列表长度
       n = len(List)
       # 2. 依次两两比较
       for i in range(1, n):
           for j in range(0, n - i):
               # 3. 前者比后者大，则交换位置
               if List[j] > List[j + 1]:
                   List[j], List[j + 1] = List[j + 1], List[j]
       return List
   
   
   if __name__ == '__main__':
       List = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
       result = bubble_sort(List)
       print(result)
   ```

3. **空间复杂度，交换时开辟了存储空间来存储中间变量，所以为 $O(1)$**

4. **时间复杂度为 $O(n^2)$**

5. **稳定性，因为关键字相等时，不存在交换，是所以稳定的**



#### **快速排序**

<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20200916013445789.gif" alt="20200916013445789" style="zoom:50%;" />

1. **算法逻辑**

   > *快速排序是一种基于分治法的排序方法。每一趟快排选择序列中任一个元素作为枢轴（pivot）通常选第一个元素，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边*

2. **算法实现**

   ```python
   def quick_sort(List):
       # 1. 原列表长度
       n = len(List)
       # 2. 若列表少于2个元素，返回当前列表（递归的结束条件）
       if n < 2:
           return List
       # 3. 选取基准值，这里选择首位元素，并将其从原列表中移除（因为要将剩下的元素分组）
       base = List[0]
       List.remove(base)
       # 3. 预先定义空列表，即基准值的左右两个列表
       left, right = [], []
       # 4. 遍历剩下的元素
       for value in List:
           if value >= base:
               # 大于等于基准值放右边
               right.append(value)
           else:
               # 小于基准值放左边
               left.append(value)
       # 5. 递归，将基准值放中间组合成已完成的有序列表
       return quick_sort(left) + [base] + quick_sort(right)
   
   
   if __name__ == '__main__':
       List = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
       result = quick_sort(List)
       print(result)
   ```

3. **时间复杂度，最好情况下，比如每次都均等二分左右部分则为 $O(nlog_n)$，待排序序列越无序，算法效率越高。最坏情况下，比如，全是 $1$ 则为 $O(n^2)$，待排序序列越有序，算法效率越低**
4. **空间复杂度，由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。最好情况下为 $O(log_2n)$ 即递归树的深度是 $⌈log_2(n+1)⌉$。最坏情况下，因为要进行 $n-1$ 次递归调用，所以栈的深度为 $O(n)$**
5. **稳定性，因为关键字相等时，存在交换，所以是不稳定的**



### **插入类**

#### **直接插入排序**

<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20200916013255688.gif" alt="20200916013255688" style="zoom:50%;" />

1. **算法逻辑**

   > *将原列表第一个元素固定，当成是已排序列表，剩下的所有元素组成待排序列表，从第二个元素开始，从后往前遍历已排序列表并进行比较，插入到顺序合适位置，重复上一步骤，直到所有元素都插入有序序列*

2. **算法实现**

   ```python
   def insert_sort(List):
       # 1. 原列表长度
       n = len(List)
       # 2. 依次遍历“待排序列表”（即原列表第2个元素开始）
       for i in range(1, n):
           # 当前待排序元素的值
           current = List[i]
           # “已排序列表”中最后一个元素的位置索引（相较于原列表）
           index = i - 1
           # 3. 从后往前遍历“已排序列表”
           while index >= 0 and current < List[index]:
               # 若小于，则交换值，继续往前遍历
               List[index + 1], List[index] = List[index], current
               index -= 1
       return List
   
   
   if __name__ == '__main__':
       List = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
       result = insert_sort(List)
       print(result)
   ```

3. **时间复杂度为 $O(n)$**
4. **空间复杂度为 $O(1)$**
5. **稳定性，因为关键字相等时，不存在交换，是所以稳定的**



#### **希尔排序**

1. **算法逻辑**

   > *希尔排序本质上是插入排序，不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序*
   >
   > 1. *先以增量 $d$（一般取序列长度的一半）来分割序列，也就是索引为 $0,d,2d,3d,\cdots$ 的元素分成一组，索引为 $1,d+1,2d+1,3d+1,\cdots$ 的元素分成一组等等，然后对这些组分别进行插入排序，就完成了一轮希尔排序*
   > 2. *接着缩小增量 $d$，比如设为 $\frac{d}{2}$ 再执行一次类似过程*
   > 3. *接下来不断重复 $2$ 直到最后一轮的增量为 1。此时就是直接插入排序*

2. **算法实现**

   ```python
   def shell_sort(List):
       # 1. 原列表长度
       n = len(List)
       # 2. 首轮排序设置的间隔增量
       h = int(n / 2)
   
       # 3. 循环分组
       while h >= 1:
           # 4. 循环每一组子列表
           for i in range(h, n):
               # 当前待排序元素的值
               current = List[i]
               # “已排序列表”中最后一个元素的位置索引（相较于原列表）
               index = i
               # 5. 每一组子列表分别进行插入排序
               while index >= h and current < List[index - h]:
                   # 若小于，则交换值，继续往前遍历
                   List[index], List[index - h] = List[index - h], current
                   index -= h
           # 6. 间隔增量缩小一半，继续循环，直到 h=1 再整体进行最后一次插入排序
           h = int(h / 2)
       return List
   
   
   if __name__ == '__main__':
       List = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
       result = shell_sort(List)
       print(result)
   ```

3. **时间复杂度，最好情况下约为 $O(n^{1.3})$，最坏情况下为 $O(n^2)$**
4. **空间复杂度为 $O(1)$**
5. **稳定性，因为不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化，所以是不稳定的**





### **选择类**

#### **简单选择排序**

<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2020091601324361.gif" alt="2020091601324361" style="zoom:50%;" />

1. **算法逻辑**

   > *从头开始，依次遍历列表，找到最小元素，选择它交换到待排序列表的最前面。每次都将产生 $1$ 个最小元素排在最前，该元素不再参与下一轮比较，相应剩余的元素作为新的待排序列表，不断重复*

2. **算法实现**

   ```python
   def select_sort(List):
       # 1. 原列表长度
       n = len(List)
       # 2. 循环（n-1）轮排序
       for i in range(n - 1):
           # 3. 记下最小元素的位置索引，默认为每轮新的待排序列表的首位i
           min_index = i
           # 4. 循环寻找待排序列表中的最小元素的位置索引，并更新min_index
           for j in range(i + 1, n):
               if List[j] < List[min_index]:
                   min_index = j
           # 5. 循环完元素后判断，若最小元素的位置索引min_index不是首位i，则交换元素
           if min_index != i:
               List[i], List[min_index] = List[min_index], List[i]
       return List
   
   
   if __name__ == '__main__':
       List = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
       result = select_sort(List)
       print(result)
   ```

3. **时间复杂度，关键操作在于交换元素操作，整个算法由双重循环组成，外层循环共 $n-1$ 次，对于第 $i$ 层外层循环，内层循环执行 $n-1-i$ 次。所以总执行次数是一个等差数列求和为 $\frac{n(n-1)}{2}$ 所以为 $O(n^2)$**
4. **空间复杂度，需要额外的存储空间仅为交换元素时借助的中间变量，所以空间复杂度是 $O(1)$**
5. **稳定性，因为最终会交换部分不必交换的元素的顺序，如 $5^*, 5, 1, 7$ 排序后变成了 $1,5,5^*,7$，所以不是稳定的**



#### **堆排序**

1. **算法逻辑**

   > *堆是一棵完全二叉树，而且小顶堆满足任何一个非叶结点的值都不大于其左右孩子结点的值（大顶堆则不小于左右孩子结点的值，一般升序采用大顶堆，降序采用小顶堆）因此，可将将原序列按顺序从上往下、从左往右的原则一个个元素插入，构建出一个堆。然后将其调整成大顶堆（所有孩子节点都与父结点比较，若大于父结点，则与父结点元素交换位置），最后将最大值即堆顶与堆尾元素交换，移除该最大值，此后得到的新堆，继续调整成大顶堆并交换堆顶与堆尾，不断重复*

2. **算法实现**

   ```python
   # 堆排序
   def heap_sort(List):
       build_heap(List)
       for i in range(len(List) - 1, -1, -1):
           List[0], List[i] = List[i], List[0]
           heapify(List, 0, i)
       return List
   
   # 构建堆，列表中元素按顺序组成堆，故自然构成无需再做调整
   def build_heap(List):
       lenght = len(List)
       # 从最后一个非叶子结点（是右结点）开始比较
       for i in range((lenght-1)//2, -1, -1):
           heapify(List, i, lenght)
   
   def heapify(List, i, lenght):
       # 1. 找到节点的左右孩子节点
       left = i*2+1
       right = i*2+2    
       # 2. 判断左右孩子节点与父节点的大小，交换最大索引值
       if left < lenght and List[left] > List[i]:
           largest = left
       else:
           largest = i
       if right < lenght and List[right] > List[largest]:
           largest = right
       # 3. 若最大值节点的索引发生变化，则交换值
       if largest != i:
           List[i], List[largest] = List[largest], List[i]   
           # 4. 递归继续寻找最大值节点索引，因为可能左右孩子结点都比根结点大
           heapify(List, largest, lenght)
   
   
   if __name__ == '__main__':
       List = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
       result = heap_sort(List)
       print(result)
   ```

3. **时间复杂度，堆排序的总时间可以分为，构建堆与选择堆顶，为 $O(nlog_2n)=O(n)+O(nlog_2n)$**
4. **空间复杂度为 $O(1)$**
5. **稳定性，因为关键字相等时，存在交换，所以是不稳定的**



### **归并类**

#### **归并排序**

<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20200916013816425.gif" alt="20200916013816425" style="zoom:50%;" />

1. **算法逻辑**

   > *假定待排序表含有 $n$ 个元素，则可以看成是 $n$ 个有序的子表，每个子表长度为 $1$，然后两两归并，得到 $⌈n/2⌉$ 个长度为 $2$ 或 $1$ 的有序表；再两两归并，如此重复，直到合并成一个长度为 $n$ 的有序表为止*
   >
   > *例如，$49,38,65,97,76,13,27$*
   >
   > 1. *将整个序列的每个关键字看成一个单独的有序的子序列*
   > 2. *两两归并，$49$ 和 $38$ 归并成 $\{38,49\}$，$65$ 和 $97$ 归并成 $\{65,97\}$，$76$ 和 $13$ 归并成 $\{13,76\}$，$27$ 没有归并对象*
   > 3. *两两归并，$\{38,49\}$ 与 $\{65,97\}$ 归并成 $\{38, 49, 65, 97\}$，$\{13,76\}$ 与 $27$ 归并成 $\{13, 27, 76\}$*
   > 4. *两两归并，$\{38, 49, 65, 97\}$ 与 $\{13, 27, 76\}$ 归并成 $\{13, 27, 38, 49, 65, 76, 97\}$*

2. **算法实现**

   ```python
   def merge(left, right):
       """
       副程序：合并排序
       """
       result = []
       while left and right:
           if left[0] <= right[0]:
               result.append(left.pop(0))  # 每次消掉首位元素
           else:
               result.append(right.pop(0)) # 每次消掉首位元素
       while left:
           result.append(left.pop(0))  # 每次消掉首位元素
       while right:
           result.append(right.pop(0)) # 每次消掉首位元素
       return result
   
   def merge_sort(List):
       """
       主程序
       """
       # 1. 原列表长度
       n = len(List)
       # 2. 若列表少于2个元素，返回当前列表（递归的结束条件）
       if n < 2:
           return List
       # 3. 拆分成左、右2个列表
       middle = n // 2
       left, right = List[0:middle], List[middle:]
       # 4. 返回递归结果
       return merge(merge_sort(left), merge_sort(right))
   
   
   if __name__ == '__main__':
       List = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
       result = merge_sort(List)
       print(result)
   ```

3. **时间复杂度为 $O(nlog_2n)$**
4. **空间复杂度，因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为 $n$ 的存储空间为 $O(n)$**
5. **稳定性，因为关键字相等时，不存在交换，是所以稳定的**



### **桶相关类**

#### **计数排序**

1. **算法逻辑**

   > *首先，找出原列表中最大值与最小值，初始化一个计数列表记录各个元素出现次数，然后，在原列表中，统计各个元素前比自己小的数的个数，然后输出（要求输入的数据必须是有确定范围的整数）*

2. **算法实现**

   ```python
   def count_sort(List):
       # 1. 原列表长度
       n = len(List)
       # 2. 初始化一个尽量大长度的“计数列表”，用来统计原列表各个元素出现次数
       max_value = max(List)
       min_value = min(List)
       count_len = max_value - min_value + 1
       count_list = [0 for i in range(count_len)]
       # 3. 初始化一个最终“结果列表”
       res = [0 for i in range(n)]
       # 4. 遍历“原列表”，统计各元素出现次数，并记录在“计数列表”（只要是同一个元素就会出现在同一位置）
       for value in List:
           # 该元素与最小值的距离
           distance = value - min_value
           count_list[distance] += 1
       # 5. 遍历“计数列表”，每个元素前一位，增加到本元素中，“计数列表”即刻更新
       for j in range(1, count_len):
           count_list[j] = count_list[j] + count_list[j - 1]
       # 6. 遍历“原列表”，统计各个元素前比自己小的数的个数，然后输出
       for value in List:
           # 该元素与最小值的距离
           distance = value - min_value
           res[count_list[distance] - 1] = value
           count_list[distance] -= 1
       return res
   
   
   if __name__ == '__main__':
   	List = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
     result = count_sort(List)
     print(result)
   ```

3. **时间复杂度为 $O(n)$**
4. **空间复杂度为 $O(n)$**
5. **稳定性，因为关键字相等时，不存在交换，是所以稳定的**



#### **桶排序**

1. **算法逻辑**

   > *首先，初始化一个个空的桶列表用于存放元素，其次，每个桶等间距的涵盖一定的数值范围，按照数的大小把数据放到对应的桶中，最后，对每个不为空的桶中数据进行排序，按桶的顺序拼接得到结果（可以排序非整数）*

2. **算法实现**

   ```python
   def bucket_sort(List):
       # 1. 原列表长度
       n = len(List)
       # 2. 初始化一个个空的“桶列表”
       min_value = min(List)
       max_value = max(List)
       bucket_len = (max_value - min_value) / n
       bucket_list = [[] for i in range(n + 1)]
       # 3. 遍历“原列表”，向“桶列表”压入元素
       for value in List:
           bucket_list[int((value - min_value) // bucket_len)].append(value)
       # 4. 声明一个返回的“结果列表”
       res = []
       # 5. 遍历“桶列表”，这里直接使用sorted排序，压入“结果列表”
       for i in bucket_list:
           for j in sorted(i):
               res.append(j)
       return res
   
   
   if __name__ == '__main__':
       List = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
       result = bucket_sort(List)
       print(result)
   
   ```

3. **时间复杂度，遍历了 $2$ 次原始数组，运算量为 $2n$，最后，遍历桶输出排序结果的运算量为 $n$，初始化桶的运算量为 $m$，对每个桶进行排序时选择不同的排序算法运算量是不同的，若选取 $n^2$ 则最多为 $O(n)=O(2n)+O(m)+O(n)+O(m\cdot(\frac{n}{m})^2)$** 
4. **空间复杂度为 $O(n)=O(n+m)$**
5. **稳定性，因为关键字相等时，不存在交换，是所以稳定的**



#### **基数排序**

<img src="./assets/%E6%88%91%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20200916013349618.gif" alt="20200916013349618" style="zoom:50%;" />

1. **算法逻辑**

   > *不是基于比较进行排序的，而是基于关键字各位的大小进行排序的，依次从后往前比较其每一位上的大小，借助分配与收集两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序*
   >
   > *对于 $53, 3, 542, 748, 14, 214, 154, 63, 616$，需要先补充位数 $053, 003, 542, 748, 014, 214, 154, 063, 616$*，其中关键字数量为 $n$，关键字的位数为 $d$，比如 $748,d=3$，$r$ 为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有 $0$ 至 $9$ 一共 $10$ 个数字，即 $r=10$

2. **算法实现**

   ```python
   def radix_sort(List):
       # 1. 记录初始排序的位置，为个位数
       index = 0
       # 2. “原列表”最大值
       max_value = max(List)
       # 3. 最大值的长度
       max_value_len = len(str(max_value))
       # 4. 循环按位数排序
       while index < max_value_len:
           # 5. 初始化一个空的[]“桶列表”
           bucket_list = [[] for i in range(10)]
           for value in List:
               # 6. 放入“桶列表”
               bucket_list[int(value / (10 ** index)) % 10].append(value)
           # 7. 清空“原列表”
           List.clear()
           # 8. 遍历“桶列表”元素，将元素放入“原列表”
           for x in bucket_list:
               for y in x:
                   List.append(y)
           # 9. 位数+1
           index += 1
       return List
   
   
   if __name__ == '__main__':
       List = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]
       result = radix_sort(List)
       print(result)
   ```

3. **时间复杂度，需要进行关键字位数 $d$ 次分配与收集，一次分配需要将 $n$ 个关键字放进各个队列中，一次收集需要将 $r$ 个桶都收集一遍。所以一次分配和一次收集时间复杂度为 $O(n+r)$。$d$ 次就需要 $O(d(n+r))$ 的时间复杂度**
4. **空间复杂度，需要开辟关键字基的个数个队列，所以为 $O(r)$**
5. **稳定性，由于不直接比较大小，在分配与收集是按照先后顺序分配，所以不会改变相同关键字的顺序，是稳定的**







## 查找算法

### 查找的基本概念和顺序查找

* 查找定义：在数据集合中寻找满足某种条件的数据元素的过程称为查找
* 关键字：数据元素中某个可以以唯一标识该元素的数据项
* 平均查找长度（ASL：Average Search Length）:在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值
* 顺序查找(线性查找)，主要用于在线性表中进行查找。从查找表的一端开始，顺序扫描查找表，依次将扫描到的关键字和待查找的值key进行比较。如果相等，则查找成功。如果扫描结束仍然没有发现相等的数据元素，则查找失败。
  * 1
  * 2
  * 3 
  * 4
  * 时间复杂度为O(n)

### 折半查找

* 算法思路：
  * 首先将给定值key与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中。然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。
* 折半查找分析
  * 折半查找判定树
    * 对于折半查找，查找的比较次数就是从根结点到该结点经历的结点数
    * 时间复杂度为O(logn)
    * 概要: 具有N个（N>0）结点的完全二叉树的高度为 [log2(N+1)] 或 [log2N] +1。

### 分块查找

* 分块查找又称为索引顺序查找
* 分块查找思想：
  * ①确定待查找值在哪个块（折半查找）

②在确定的块中查找待查找值（顺序查找）

* 分块查找分析
  * 由于分块查找实际是进行两次查找，所以整个算法的平均查找长度是两次查找的平均查找长度之和。
    即ASL分块=ASL折半+ASL顺序

### B树和B+树

* 2-3树
  * 2-3树是一种多路查找树：2和3的意思就是2-3树包含两种结点
    * 1)2结点包含一个元素和两个孩子(或者没有孩子)。
      ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值
      ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子
    * 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。(两个元素按大小顺序排列好)
      ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。
      ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子
    * 3)2-3树所有叶子结点都在同一层次
* 2-3-4树
  * 2-3-4树也是一种多路查找树：2和3和4的意思就是2-3-4树包含三种结点
    * 1)2结点包含一个元素和两个孩子(或者没有孩子)。
      ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值
      ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子
    * 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。
      ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。
      ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子
    * 3)4结点包含小中大三个元素和四个孩子(或者没有孩子)。
      ①左子树包含的元素小于该结点最小的元素值，第二个子树包含大于最小的元素值小于中间元素值的元素，第三个子树包含大于中间元素值小于最大元素值的元素，右子树包含的元素大于该结点最大的元素值。   
      ②4结点要不有四个孩子，要不就没有孩子，不允许有一个或两个或三个孩子
    * 4)2-3-4树所有叶子结点都在同一层次
* B树
  * B树也是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，我们把树中结点最大的孩子数目称为B树的阶。通常记为m。
    一棵m阶B树或为空树，或为满足如下特性的m叉树：
      * 1）树中每个结点至多有m棵子树。（即至多含有m-1个关键字) ("两棵子树指针夹着一个关键字")
      * 2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字)
      * 3）除根结点外的所有非叶结点至少有 ⌈m/2⌉棵子树。（即至少含有⌈m/2⌉-1个关键字）
      * 4）所有非叶结点的结构如下：
      * 5）所有的叶子结点出现在同一层次上，不带信息。(就像是折半查找判断树中查找失败的结点)
  * 1.B树的查找操作
    * 查找过程：①先让待查找关键字key和结点的中的关键字比较，如果等于其中某个关键字，则查找成功。
          ②如果和所有关键字都不相等，则看key处在哪个范围内，然后去对应的指针所指向的子树中查找。
              Eg:如果Key比第一个关键字K1还小，则去P0指针所指向的子树中查找，如果比最后一个关键字Kn还大，则去Pn指针所指向的子树中查找。

  * 2.B树的插入操作
    * 分裂的方法：取这个关键字数组中的中间关键字(⌈n/2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。
  * 3.B树的删除操作
    * B树中的删除操作与插入操作类似，但要稍微复杂些，要使得删除后的结点中的关键字个数≥⌈m/2⌉-1 ，因此将涉及结点的“合并”问题。由于删除的关键字位置不同，可以分为关键字在终端结点和不在终端结点上两种情况。
      * 1）如果删除的关键字在终端结点上（最底层非叶子结点）：
        ①结点内关键字数量大于⌈m/2⌉-1 ，这时删除这个关键字不会破坏B树的定义要求。所以直接删除。
        ②结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中存在关键字数量大于⌈m/2⌉-1 的结点，则去兄弟阶段中借关键字。
        ③结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中不存在关键字数量大于⌈m/2⌉-1 的结点，则需要进行结点合并。

      * 2）如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上，再按照在终端结点     上的情况来分别考虑对应的方法。
        * 相邻关键字：对于不在终端结点上的关键字,它的相邻关键字是其左子树中值最大的关键字或者右子树中值最小的关键字。
        * 第一种情况：存在关键字数量大于⌈m/2⌉-1 的左子树或者右子树，在对应子树上找到该关键字的相邻关键字，然后将相邻关键字替换待删除的关键字。
        * 第二种情况：左右子树的关键字数量均等于⌈m/2⌉-1 ，则将这两个左右子树结点合并，然后删除待删除关键字。
* B+树
  * B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构
  * m阶的B+树与m阶的B树的主要差异在于：
    1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。
    2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m/2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m/2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。
    3）在B+树中，叶结点包含信息，所有非叶结点仅起到索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。
    4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。

### 散列表

* 散列表：根据给定的关键字来计算出关键字在表中的地址的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。
* 散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr。
* 散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。
* 构造散列函数的tips：
  * 1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。
  * 2）散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生。
  * 3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。
* 1.常用Hash函数的构造方法：
  * 1.开放定址法：直接取关键字的某个线性函数值为散列地址，散列函数为H(key)=a×key+b。式中，a和b是常数。这种方法计算最简单，并且不会产生冲突
  * 2.除留余数法：假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为H(key)=key % p
    除留余数法的关键是选好p，使得每一个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性
  * 3.数字分析法：设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合
  * 4.平方取中法：顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。
  * 5.折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。

* 2.常用Hash函数的冲突处理办法：
  * 1.开放定址法：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。
    * 1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。
    * 2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为d+12，d-12，d+22，d-22......
      平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。
    * 3）再散列法：又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(Key)得到的地址发生冲突时，则利用第二个散列函数Hash2(Key)计算该关键字的地址增量。
    * 4）伪随机序列法：当发生地址冲突时，地址增量为伪随机数序列，称为伪随机序列法。
  * 2.拉链法：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。
  * 3.散列表的查找过程：类似于构造散列表，给定一个关键字Key。
    先根据散列函数计算出其散列地址。然后检查散列地址位置有没有关键字。
       1)如果没有，表明该关键字不存在，返回查找失败。
       2)如果有，则检查该记录是否等于关键字。
               ①如果等于关键字，返回查找成功。
               ②如果不等于，则按照给定的冲突处理办法来计算下一个散列地址，再用该地址去执行上述过程。
  * 4.散列表的查找性能：和装填因子有关。
    *  
    *  α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小



